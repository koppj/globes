
CVS to git move of the central repo
----------------------------------

This here is take two, I installed the same recent git version on both
sides of the problem.

- Install git v1.5.3

- Install cvsps (only need for the inital import from CVS)

- Create target directory, i.e. place where the new git repository is going to live.



----------------------------------------------------------------------
$ export CVS_RSH="ssh"
$ git cvsimport -v -d globes@lfs3.mpi-hd.mpg.de:/home/lin/globes/cvs Projects/GLOBES
----------------------------------------------------------------------

which should not take more than one hour (Heidelberg->Madison) and
should be much faster locally.

NB Size goes from 280MB to 140MB


In the central repo, I deleted branches
 
 Web lin patrick

since they correspond to some old modules, no one is using anymore.


Organizing releases, branches etc.
----------------------------------

After doing a bit of research, I can imagine following scheme for
`GLoBES` release management:

..........................
                 tag-version-3-0
                  |
                  | tag-version-3-0-1
                  | |                  
                  | |           tag-version-3-0-2
                  | |            |			
  debugging -> o-o-o-----------o-o- <-version-3-0
              /    ^           ^
             /     |           |               o-o-o-o-o- <- version-3-2
            /    bug fix     bug fix          /
           /       |           |             /
-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o <-master
              \               \           /
               \               \         /
                \               o-o-o-o-o <-feature-foobar	
                 \             
                  o-o-o-o-o <-feature-foobaz
..........................

The idea is that all active development happens on `master`, however
only changes which actually work (at least in some definition) are
integrated into `master`. Especially, the API should be more or less
final on `master`. The version on `master` should always be
usable. New features and experimental development is done on feature
branches, like `feature-foobaz`. The development in `feature-foobaz`
turned out be lead nowhere, hence the branch is not merged. We don't
delete it, since maybe sometime later we may want to come back to
it. `feature-foobar`, on the other hand is merged into `master` since
we want to keep that feature. The branch is deleted afterwards. When
we decide it's time for a new major version 3.x, we create a
corresponding branch `version-3.x` and set the version number in
`configure.in` in the `version-3.x` branch to 3.x and in master to
3.x+1. There me be a pre-release phase on then `version-3.x` branch,
the API may be fine tuned etc. After some time we freeze the addition
of features and API changes and start debugging and testing. Once
we're ready we tag the branch with `tag-version-3.x` and make the
release. Bugs will be fixed on `master` and then merged into
`version-3-x`. At which point we tag and release a minor version 3.x.y+1
etc. Version branches never are deleted, although we will not merge
bug fixes in any previous version branches, but always only in the
most recently released one.

Version numbering
~~~~~~~~~~~~~~~~~

On any of the version branches it is fairly simple: after release of
3.x `version-3.x` will have versions 3.x.0, 3.x.1 etc. On `master` we
have 3.x+1 and will count all changes like 3.x+1.0, 3.x+1.1 etc. The
next release version then always will be 3.x+2. That implies in the
current system, that all public releases will haven an even x,
i.e. 3.0, 3.2, 3.4 ...

The real issue is are feature branches, how do we count on them?
Adding forth digit? For instance, assume `feature-foobaz` is branched
from `master` at version 3.1.0, the its first commit would be version
3.1.0.0 and then 3.1.0.1. That requires that not two feature branches
start at the same version, which I think can be arranged.


..................................

        pre-release finalization    release  bugfixes
         |    |       |       |        |         |
    2.9.12->2.9.13->2.9.14->2.9.15-->3.0.0--->3.0.1-->   version-3-0
    /
   /	
-2.9.12->3.1.0->3.1.1->3.1.2---->3.1.3--------->3.1.4    master
                         \         \
                          \       3.1.3.0->3.1.3.1       feature-foobar
                           \
                        3.1.2.0->3.1.2.1->3.1.2.2        feature-foobaz
..................................

The only thing we can't fit into that scheme are private feature
branches, on the other hand they are private and hence it's everyone's
private buissiness to organize that. 

Tagging
~~~~~~~

We require tagging only for release, so that getting the the state of
the repo when a certain version was release is easy. Besides, we
may tag major events, like fixing the chi^2 bug.


Implementation
~~~~~~~~~~~~~~



Bob wants to colla

-----------------------
$ git tag -l
  last-time-module
  mass-ordering
  pre-release
  release
  release-3-0-0
  start
  version-1-7-7
  version-1-8
  version-1-8-2 
  version-2-0-0
  version-2-0-1
  version-2-0-1-beta
------------------------

and decides to create a new branch which starts at release-3-0-0 

-----------------------------------------
$ git checkout -b version-3-0 release-3-0-0
-----------------------------------------

this also switches to that branch next we`d like to merge all changes
which happened since the tag release-3-0-0 was created to this branch

-----------------
$ git pull . master
-----------------

Now we have the following structure

         o-o-o-o-o-o-o-o-o-o-o-o version-3-0  
        /                      | merge from master
-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o-o master
       |
     release-3-0-0

Now, one can add new features to master and do the maintenance and
bug-fixing for version 3.0 on the version-3-0 branch.

Next we need to make that public. First we push our new branch
 
----------------------------
$ git push origin version-3-0
----------------------------

Next we need to ensure that this branch gets pulled as well.

--------------------------------------------------------------
$ git config branch.version-3-0.remote origin
$ git config branch.version-3-0.merge refs/heads/version-3-0
--------------------------------------------------------------

These are the same things 

--------------------------------------------------
$ git branch --track version-3-0 origin/version-3-0
--------------------------------------------------

would create, but Bob has that branch already.


Updating the website
--------------------

Clearly the transition to `git` will require to adapt the
`webupdate-globes` script.

--------------------------------
#
# update from cvs
echo "Updating from CVS ..."
cvs update -dP
#
--------------------------------

will need to appropriately replaced.

We extract current tar-ball out of the git central repo and unpack it
into `web-tmp`

----------------------------
$ git-archive --format=tar --remote=path-to-central-repo refs/heads/version-3-0:Web-3.0 > web.tar
$ tar -xf web.tar
----------------------------

where `version-3-0` has to be replaced with the right branch, i.e if you
do that for version 3.2, one has to use `version-3-2`.

The good thing about specifying the branch directly, is that we can
already update the webpages for release 3.2 without interefering with
maintenance of the webpages for version 3.0.
