%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PART I: User's manual
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\part{User's manual}
\chapter{A short \GLOBES\ tour}

To be written later: Short introduction such as ``With the following lines we obtain ...''
without detailed description of parameters. Should contain all most important functions of \GLOBES\ --
overview of main functions in \tabl{stdfunctions}.
Maybe: in form of long example which involves everything (for example: our famous bar plot, which involves
systematics, correlations, degeneracies and thus the full set of \GLOBES\ functions without being too
complicated in the application software part).

\begin{table}[t]
\begin{center}
\begin{tabular}{p{1.8cm}p{4.5cm}p{8.6cm}}
\hline
Function & Purpose & Parameters \ra\ Result \\
\hline
{\tt Chi} & $\chi^2$ with systematics only \newline (all initialized exps.) & ($\{ \theta_{12}, \theta_{13}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho_1},... , \hat{\rho_n} \}$)  \newline \ra\  $\chi^2$ \\[0.1cm]
{\tt SingleChi} & $\chi^2$ with systematics only \newline (only one experiment) & $(\{ \theta_{12}, \theta_{13}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}} )$   \newline \ra\ $\chi^2$ \\[0.1cm]
{\tt ChiTheta} & $\chi^2$ with systematics and correlations: Projection onto $\theta_{13}$-axis (all exps.) &  ($ \theta_{13}, \, \{ \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho_1}, ... , \hat{\rho_n} \}$) \newline \ra\  $\{ \chi^2, \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho_1}, ... , \hat{\rho_n} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
{\tt Single-} \newline {\tt ChiTheta} & $\chi^2$ with systematics and correlations: Projection onto $\theta_{13}$-axis (one exp.) &  ($ \theta_{13}, \, \{ \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm,  \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}}$) \newline \ra\  $\{ \chi^2, \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho}_{N_{\mathrm{exp}}} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
{\tt ChiDelta} & $\chi^2$ with systematics and correlations: Projection onto $\deltacp$-axis (all exps.) &  ($\deltacp, \, \{ \theta_{12}, \theta_{13}, \theta_{23},  \sdm , \ldm, \hat{\rho_1}, ... , \hat{\rho_n} \}$) \newline \ra\  $\{ \chi^2, \theta_{12}, \theta_{13}, \theta_{23}, \sdm , \ldm, \hat{\rho_1}, ... , \hat{\rho_n} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
{\tt Single-} \newline {\tt ChiDelta} & $\chi^2$ with systematics and correlations: Projection onto $\deltacp$-axis (one exp.) &  ($ \deltacp, \, \{ \theta_{12}, \theta_{13}, \theta_{23}, \sdm , \ldm,  \hat{\rho}_{N_{\mathrm{exp}}}  \}, \, N_{\mathrm{exp}}$) \newline \ra\  $\{ \chi^2, \theta_{12}, \theta_{13}, \theta_{23},  \sdm , \ldm, \hat{\rho}_{N_{\mathrm{exp}}} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
{\tt ChiTheta-} {\tt Delta} & $\chi^2$ with systematics and correlations: Projection onto $\deltacp$-$\theta_{13}$-plane (all exps.) &  ($\theta_{13}, \, \deltacp, \, \{ \theta_{12}, \theta_{23},  \sdm , \ldm,  \hat{\rho_1}, ... , \hat{\rho_n} \}$) \newline \ra\  $\{ \chi^2, \theta_{12}, \theta_{23}, \sdm , \ldm,  \hat{\rho_1}, ... , \hat{\rho_n} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
{\tt SingleChi-} {\tt Theta- } {\tt Delta} & $\chi^2$ with systematics and correlations: Projection onto $\deltacp$-$\theta_{13}$-plane (one exp.) &  ($ \theta_{13}, \, \deltacp, \, \{ \theta_{12}, \theta_{23}, \sdm , \ldm,  \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}}$) \newline \ra\  $\{ \chi^2, \theta_{12},  \theta_{23},  \sdm , \ldm, \hat{\rho}_{N_{\mathrm{exp}}} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
{\tt ChiNP} & $\chi^2$ with systematics and correlations: Projection onto $N$-parameter hyper-plane (one exp.) & ??? to be defined \\[0.1cm]
{\tt Single-} {\tt ChiNP} & $\chi^2$ with systematics and correlations: Projection onto $N$-parameter hyper-plane (one exp.) & ??? to be defined \\[0.1cm]
{\tt ChiAll} & Lokal minimum of $\chi^2$ with respect to all parameters (all exps.) &
($ \{ \theta_{13}, \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm,  \hat{\rho_1}, ... , \hat{\rho_n} \}$) \newline \ra\  $\{ \chi^2, \theta_{13}, \theta_{12}, \theta_{23},$ \newline \hspace*{1.4cm} $ \deltacp , \sdm , \ldm,  \hat{\rho_1}, ... , \hat{\rho_n} , N_{\mathrm{Iter}} \}$ 
\\[0.1cm]
{\tt Single-} {\tt ChiAll} & Lokal minimum of $\chi^2$ with respect to all parameters (one exp.) &  ($ \{ \theta_{13}, \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm,  \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}}$) \newline \ra\  $\{ \chi^2, \theta_{13}, \theta_{12}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho}_{N_{\mathrm{exp}}} , N_{\mathrm{Iter}} \}$ \\[0.1cm]
\hline
\end{tabular}
\end{center}
\caption{\label{tab:stdfunctions} \index{Standard functions (table)} The \GLOBES\ standard function to obtain a $\chi^2$-value for all or one of the initialized experiments. The curly brackets refer to the parameters to be transferred in form of a list. The parameter $\hat{\rho}_i \equiv \rho_i/\bar{\rho}_i$ refers to the matter density scaling factor, which is $1.0$ for leaving the matter density profile unchanged. Note that all functions but {\tt Chi} and {\tt SingleChi} are using minimizers which have to be initialized with {\tt SetInputErrors} and {\tt SetStartingValues} first.}
\end{table}

\chapter{Getting started with \GLOBES }

In this first chapter of the user's manual, we assume that the \GLOBES\ software is readily installed on your computer system. We demonstrate how to load pre-defined experiments and re-obtain information about them. However, we only secondarily discuss the usage of \GLOBES\ in your specific programming language, such as C, Mathematica, or others. Thus, you should be familiar of how to load \GLOBES\ on your computer system before reading this chapter. An example of how to use \GLOBES\ with C can be found on page~\pageref{ex:c}. 

\example{Using \GLOBES\ with C}{\label{ex:c}
\index{C-Code}

Here comes some complete C-code with a very simple example of how to use \GLOBES .
 
}

\begin{table}[t]
\begin{center}
\begin{tabular}{lll}
\hline
Quantities & Examples & Units \\
\hline
Angles & $\theta_{13}$, $\theta_{12}$, $\theta_{23}$, $\deltacp$ & Radians  \\
Mass squared differences & $\sdm$, $\ldm$ & $\mathrm{eV}^2$ \\
Matter densitities & $\rho_i$ & $\mathrm{g}/\mathrm{cm}^3$ \\
Baseline lengths & $L_i$ & $\mathrm{km}$ \\
Energies & $E_\nu$ & $\mathrm{GeV}$ \\  
Fiducial masses & $m_{\mathrm{Det}}$ & $\mathrm{kt}$ \\
Time intervals & $t_{\mathrm{run}}$ & $\mathrm{yr}$ \\
Source powers & $P_{\mathrm{Source}}$ & ??? \\
% Integrated luminosities & $m_{\mathrm{Det}} \, t_{\mathrm{run}}$ & $\mathrm{kt \cdot yr}$ \\
Cross sections & $\sigma_{\mathrm{CC}}$ &  ???? \\
\hline
\end{tabular}
\mycaption{\label{tab:units} \index{Units in \GLOBES } Quantities used in \GLOBES , examples of these quantities, and their standard units in the application software.}
\end{center}
\end{table}

Throughout the programming interface of \GLOBES , the software needs to transfer parameters to and from the software core. Unless the Experiment Definition Module \EDM , the programming interface only uses one set of units for each type of quantity in order to avoid confusion about the definition of individual parameters. \tabl{units} summarizes the units of the most important quantities used in \GLOBES .

\begin{table}[t]
\begin{center}
\begin{tabular}{llp{7cm}c}
\hline
Experiment & Filename & Short description & Refs. \\
\hline 
\multicolumn{3}{l}{\underline{Conventional beams:}} \\
??? & & \\[0.1cm]

\multicolumn{3}{l}{\underline{First-generation superbeams:}} \\
\JHFSK\ ($\nu$) & {\tt JHFSK.exp} & JHF (J-PARC) to Super-Kamiokande, neutrino running &  \cite{Huber:2002mx,Huber:2002rs} \\
\JHFSK\ ($\bar\nu$)& {\tt JHFSKanti.exp} & JHF (J-PARC) to Super-Kamiokande, antineutrino running &  \cite{Huber:2002rs} \\
\NUMI\  ($\nu$), OA $9 \, \mathrm{km}$ & {\tt NUMI9.exp} & NuMI with off-axis angle of $9 \, \mathrm{km}$ for $L=712 \, \mathrm{km}$, neutrino running & \cite{Huber:2002rs} \\
\NUMI\  ($\bar{\nu}$), OA $9 \, \mathrm{km}$ & {\tt NUMI9anti.exp} & NuMI with off-axis angle of $9 \, \mathrm{km}$ for $L=712 \, \mathrm{km}$, antineutrino running & \cite{Huber:2002rs} \\
\NUMI\  ($\nu$), OA $12 \, \mathrm{km}$ & {\tt NUMI12.exp} & NuMI with off-axis angle of $12 \, \mathrm{km}$ for $L=712 \, \mathrm{km}$, neutrino running & \cite{Huber:2002rs} \\
\NUMI\  ($\bar{\nu}$), OA $12 \, \mathrm{km}$ & {\tt NUMI12anti.exp} & NuMI with off-axis angle of $12 \, \mathrm{km}$ for $L=712 \, \mathrm{km}$, antineutrino running & \cite{Huber:2002rs} \\
\SPL\  ($\nu$) & {\tt SPL.exp} & SPL (CERN), neutrino running &  ??? \\
\SPL\  ($\bar\nu$) & {\tt SPLanti.exp} & SPL (CERN), antineutrino running & ??? \\[0.1cm]
 
\multicolumn{3}{l}{\underline{Superbeam upgrades:}} \\
\JHFHK\ ($\nu$) & {\tt JHFHK.exp} & JHF (J-PARC) to Hyper-Kamiokande superbeam upgrade, neutrino running &  \cite{Huber:2002mx,Huber:2002rs} \\
\JHFHK\ ($\bar\nu$)& {\tt JHFHKanti.exp} & JHF (J-PARC) to Hyper-Kamiokande superbeam upgrade, antineutrino running &  \cite{Huber:2002mx,Huber:2002rs} \\[0.1cm]

\multicolumn{3}{l}{\underline{Neutrino factories:}} \\
\NuFactI\ & {\tt NuFact.exp} & Initial stage neutrino factory, symmetric operation in both polarities & \cite{Huber:2002mx} \\
\NuFactII\  & {\tt NuFact2.exp} & Advanced stage neutrino factory, symmetric operation in both polarities & \cite{Huber:2002mx,Huber:2003ak} \\[0.1cm]

\multicolumn{3}{l}{\underline{Reactor experiments:}} \\
\ReactorI\ & {\tt Reactor.exp} & Small reactor experiment with identical near and far detectors & \cite{Huber:2003pm} \\
\ReactorII\ & {\tt Reactor2.exp} & Large reactor experiment with identical near and far detectors & \cite{Huber:2003pm} \\[0.1cm]

\multicolumn{3}{l}{\underline{$\beta$-Beams:}} \\
\Beta\ ($\nu$) & {\tt BETA.exp} & $\beta$-Beam, neutrino running & ??? \\
\Beta\ ($\bar\nu$) & {\tt BETAanti.exp} & $\beta$-Beam, antineutrino running & ??? \\
\hline
\end{tabular}
\end{center}
\mycaption{\label{tab:experiments} \index{Experiment data files (table)} Different pre-defined experiments, their filenames (to be used in {\tt LoadExperiment}), their short description, and the references in which they are defined. Note that all experiments use in their standard configurations one year of running time. Details about the experiment parameters can be obtained with {\tt InfoExperiment}(Experiment number) after they have been loaded.}
\end{table}

In principle, \GLOBES\ can handle any number of different long-baseline experiments simultaneously. This means that their $\chi^2$-values are added {\em after} the minimization over the independent systematics parameters and {\em before} any minimization over the oscillation parameters. Though the simplest case of only one experiment may be most often used, more experiments are useful in many cases. For example, running a superbeam some years in the neutrino mode and some years in the antineutrino mode can be, to a first approximation, simulated by the combination of two such experiments.\footnote{Note that in this case the systematics parameters are minimized over independently, which means that this approach does not allow correlations among the systematics parameters. Therefore, the neutrino factory with the symmetric operation of both polarities is encapsulated into a single experiment.} Another example is the test of synergetic effects among different experiment types. Thus, \GLOBES\ has an internal (initially empty) list of currently initialized experiments. To add a pre-defined experiment to this list, one can use the function {\tt LoadExperiment}:
\begin{function}
\index{{\tt LoadExperiment}}
\index{Experiment initialization}
{\tt LoadExperiment}$($``filename'' $)$ adds a single experiment to the list of currently loaded experiments. All currently loaded experiments are evaluated simultaneously (if not explicitely stated otherwise), \ie , their $\chi^2$-values are added.
\end{function}
A list of pre-defined experiment types, their filenames, their short descriptions, and the references of their definitions can be found in \tabl{experiments}. To remove all experiments from the evaluation list, one uses {\tt ClearExp}:
\begin{function}
\index{{\tt ClearExp}}
{\tt ClearExp}$()$ removes all experiments from the evaluation list.   
\end{function}
Both functions do not return anything. Thus, one can either add an experiment to the internal evaluation list, or remove all experiments from this list. After adding an experiment, it gets an internal experiment number $N_{\mathrm{exp}}$ assigned in the order of the addition, which is starting from zero and running to the number of experiments minus one. Therefore, one will be able to access the individual experiment by its number later.

Since the pre-defined experiments in \tabl{experiments} are given for one year running time, specific target masses, and specific source powers, it is useful to change these parameters of the individual experiments:
\begin{function}
\index{{\tt SetRunningTime}}
{\tt SetRunningTime}$(N_{\mathrm{exp}},t_{\mathrm{run}})$ sets the running time of experiment number $N_{\mathrm{exp}}$ to $t_{\mathrm{run}}$ years.
\end{function}
 \begin{function}
\index{{\tt SetTargetMass}}
{\tt SetTargetMass}$(N_{\mathrm{exp}},m_{\mathrm{Det}})$ sets the fiducial mass of experiment number $N_{\mathrm{exp}}$ to $m_{\mathrm{Det}}$ kilotons.
\end{function}
\begin{function}
\index{{\tt SetSourcePower}}
{\tt SetSourcePower}$(N_{\mathrm{exp}},P_{\mathrm{Source}})$ sets the source power of experiment number $N_{\mathrm{exp}}$ to $P_{\mathrm{source}}$. The definition of the source power depends on the experiment type: ... (MISSING).
\end{function}
Thus, these functions also demonstrate how to use the assigned experiment number.

A useful function to re-obtain the information about the initialized experiments is the function {\tt InfoExperiment}:
\begin{function}
\index{{\tt InfoExperiment}}
{\tt InfoExperiment}$()$ prints a list of the initialized functions with their experiment numbers and their most important parameters to the standard output.
\end{function} 
Especially, after changing individual parameters, such as baseline or target mass, this information can be useful to check the changes. Another useful function is {\tt ShowChannels}, which prints the initialized oscillation channels for a specified experiment:
\begin{function}
\index{{\tt ShowCannels}}
{\tt ShowChannels}$(N_{\mathrm{exp}})$ prints the information about the oscillation channels of the experiment with the number $N_{\mathrm{exp}}$ to the standard output.
\end{function}

Compared to an existing experiment, which uses real data, a future experiment uses simulated data. Thus, the {\em true parameter values} and their results in form of the reference rate vectors are simulated. After setting the true parameter values, the {\em fit parameter values} can be varied in order to obtain information on the measurement performance for the given set of true parameter values. Therefore, it is often useful to show the results of a future measurement as function of the true parameter values for which the reference rate vectors are computed -- at least within the currently allowed ranges. The true parameter values for the vacuum neutrino oscillation parameters have to be set by the functions {\tt SetVacuumParameters} and {\tt SetRates} {\em before} any evaluation function is used and {\em after} the experiments have been initialized and the experiment parameters have been adjusted which could change the rates (such as baseline or target mass). Any matter effects are then included automatically depending on the experiment definitions.
\begin{function}
\index{{\tt SetVacuumParameters}}
{\tt SetVacuumParameters}$(\{\theta_{12}, \theta_{13}, \theta_{23}, \deltacp , \sdm , \ldm \})$ sets the neutrino oscillation parameters to be used to compute the reference rate vector in vacuum.
\end{function}
\begin{function}
\index{{\tt SetRates}}
{\tt SetRates}$( )$ computes the reference rate vector for the neutrino oscillation parameters set with {\tt SetVacuumParameters}. 
\end{function}
Finally, an initialization sequence for \GLOBES\ could look like this:
\begin{quote}
{\tt
ClearExp(); \\
InitExperiment("JHFHK.exp"); \\
SetRunningTime(0, 2.0); \\
InitExperiment("JHFHKanti.exp"); \\
SetRunningTime(1, 6.0);\\
MInfoExperiment(); \\
SetVacuumParameters(\{0.55, 0.16, 3.14/4, 3.14/2, 7e-5, 2e-3\}); \\
SetRates();
} 
\end{quote}
This piece of code initializes the JHF (J-PARC) to Hyper-Kamiokande superbeam upgrade with two years of neutrino running and six years of antineutrino running, \ie, an overall running time of eight years. The final configuration is then printed to the standard output and the reference rate vector is set to the chosen parameter values.

\chapter[Calculating $\chi^2$ with systematics only]{Calculating $\boldsymbol{\chi^2}$ with systematics only}

\index{Systematics}
Calculating a $\chi^2$-value with or without systematics, but no correlations and degeneracies, is the simplest and fastest possibility to obtain high-level information on an experiment. I general, \GLOBES\ uses the six independent oscillation parameters $\theta_{12}$, $\theta_{13}$, $\theta_{23}$, $\deltacp$, $\sdm$, $\ldm$, as well as the matter density of each experiment. Thus, there are six plus the number of experiments parameters determining the rate vectors. Using the matter densities in addition to the oscillation parameters will allow the simulation of matter density uncertainties: In this approach, the matter densities can be treated as parameters to be measured by the experiments within certain limits, where the limits are given by the observed precision of the matter density profile. Defining a independent matter density for each experiment is necessary if the baselines are completely uncorrelated. For correlated or even identical baselines, one may rather want to encapsulate the experiments into a single experiment definition. 

\example{Correlation between $\stheta$ and $\deltacp$}{
\label{ex:corrth13dcp}

\index{Two-parameter correlation}
A typical application for {\tt Chi} and {\tt SingleChi} is the visualization of two-parameter correlations. For example, to show the correlation between $\stheta$ and $\deltacp$ at a large neutrino factory with four years of running time for each polarity, one can use the following code:
\begin{quote}
{\tt
/\% Experiment initialization: \%/ \\
ClearExp(); \\
 InitExperiment("{\tt NuFact2.exp}"); \\
 SetRunningTime(0,4.0); \\
 MInfoExperiment(); \\
\\
/\% Set reference rate vector: \%/ \\
th12=arcsin(sqrt(0.8))/2; sdm=7e-5; \\
th23=3.14/4; ldm=2e-3; \\
th13=arcsin(sqrt(0.001))/2; dcp=3.14/2; \\
\mbox{SetVacuumParameters(\{th12, \, th13, \, th23, \, dcp, \, sdm, \, ldm\}); }\\
 SetRates(); \\
\\
/\% Compute chi-square matrix: \%/ \\
for (float x=-4; x<-2; x=x+2/50) \\
\hspace*{0.5cm} for (float y=0; y<200; y=y+200/50) \{ \\
\hspace*{1cm} theth13 = arcsin(sqrt(10$\hat{\, \, \,}$x))/2; \\
\mbox{\hspace*{1cm} Print(\{x,y,Chi(\{th12, theth13,  th23,  y, sdm, ldm, 1.0\}) \}) \};}
}
\end{quote}

The resulting matrix can then be plotted as a contour plot (2 d.o.f.):
\begin{center}
\colorbox{white}{\includegraphics[width=8cm]{correx}}
\end{center}

}

Keeping all oscillation parameters and matter densities fixed, one can use the following functions to obtain the total $\chi^2$ of all specified oscillation channels including systematics:
\begin{function} 
\index{{\tt Chi}}
{\tt Chi}$(\{ \theta_{12}, \theta_{13}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho_1}, \hdots , \hat{\rho_n} \})$  returns the total added $\chi^2$ of all loaded experiments.
\end{function}
\begin{function}
\index{{\tt SingleChi}}
 {\tt SingleChi}$(\{ \theta_{12}, \theta_{13}, \theta_{23}, \deltacp , \sdm , \ldm, \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}} )$  returns the total $\chi^2$ of the experiment number $N_{\mathrm{exp}}$.
\end{function}
Note that the result of {\tt Chi} corresponds to the sum of all of the {\tt SingleChi}'s of the loaded experiment. This equality will not hold for the minimizors in the next sections anymore. In both functions, one has to give the matter density scaling factor $\hat{\rho_i}$ for each of the used experiments. The effect of this scaling factor depends on the type of the matter density profile, which is given in the  experiment definition. For a constant matter density, it is simply the ratio of the matter density and the average matter density specified in the experiment definition, \ie , $\hat{\rho_i} \equiv \rho_i/\bar{\rho}_i$.\index{Matter scaling factor} For a matter density profile, it is an overall scaling factor: The matter density in each layer is multiplied by this factor. In most cases one wants to take a scaling factor of $1.0$ here, which simply means taking the matter density profile as it is given in the experiment definition. Moreover, note that its effect is in general small for short baselines. An example of how to use  {\tt Chi} (or {\tt SingleChi}) can be found on page~\pageref{ex:corrth13dcp}.  

\index{Systematics}
The treatment of systematics is done by the usage of auxiliary systematics parameters, which are taken completely uncorrelated among different oscillation channels, and treated with simple Gaussian statistics. One such example is the signal normalization error, \ie, an error to the overall normalization of the signal. For illustration, we assume that the signal event rate in the $i$th bin $s_i^0$ of one oscillation channel is altered by the overall normalization auxiliary parameter\index{Auxiliary parameter} of this channel, \ie , 
\be
 s_i = s_i(n_s) = s_i^0 \cdot (1 + n_s),
\ee
where $n_s$ is the signal normalization parameter. The total number of events in the $i$th bin $x_i$ also includes the background event rates $b_i$, \ie, $x_i = s_i + b_i$, which may have their own systematics parameters.
In order to implement an overall signal normalization error $\sigma_{n_s}$,  the $\chi^2$, which includes all event rates $x_i$ of all bins, is minimized over the auxiliary parameter $n_s$:
\be
 \hat{\chi^2} = \underset{n_s}{\mathrm{min}} \left(  \chi^2(n_s, \hdots) + \frac{(n_s)^2}{\sigma_{n_s}^2} \right).
\ee 
This minimization is done independently for all auxiliary parameters of this oscillation channel. The total $\chi^2$ for the considered experiment is finally obtained by repreating this procedure for all oscillation channels and adding their $\chi^2$-values. In general, the situation is more complicated because of the usage of many systematical errors. More details about systematics parameters and the definition of signal, background, and oscillation channels can be found in the \EDM\ part of this book, too.

The systematics minimization of an experiment can be easily switched on and off, \ie, one can also compute the $\chi^2$ without even taking into account systematics:
\begin{function}
\index{{\tt SetSystematics}}
{\tt SetSystematics}$(N_{mathrm{exp}}, \, sys)$ switches the systematics minimization for experiment $N_{\mathrm{exp}}$ on (sys=1) or off (sys=0).
\end{function}
This function can be especially useful for the test of the impact of systematics.
??? Wie einzelne Systematik-Parameter ein und ausschalten? Sonst individuell nicht testbar! ??? Verweis auf appendix? 

\chapter[Calculating $\chi^2$-projections: how one can include correlations]{Calculating $\boldsymbol{\chi^2}$-projections: how one can include correlations}

\index{Multi-parameter correlation}
This chapter deals with the rather complicated issue of $n$-parameter correlations. Since it has before this software  not been possible to include the full $n$-parameter correlations in the high-dimensional parameter space with reasonable effort, it is the core part of this software  -- as well as its strength. Of course, calculating $\chi^2$-projections is somewhat more complicated than using systematics only. Therefore, we use a simple step by step introduction to the problem. 

\section{Introduction}

\index{Projection of manifold}
In principle, the precision of an individual parameter measurement including correlations can be obtained as the projection of the $n$-dimensional fit manifold onto the respective axis. Similarly, one can project the fit manifold onto a plane, such as the $\stheta$-$\deltacp$-plane, if one wants to explicitely show this correlation with all the other parameter correlations included. In practice, this projection is very difficult: a grid-based method would need $(N_{\mathrm{grid}})^n$ function calls of {\tt Chi} or {\tt SingleChi} to calculate the precision including the full $n$-parameter correlation, where $N_{\mathrm{grid}}$ is the number of points in each direction of the lattice. For example, taking only $N_{\mathrm{grid}}=20$ and $n=7$ (six oscillation parameters and matter density) would mean more than one billion function calls of {\tt Chi} or {\tt SingleChi}. One can easily image that this is too much for any sophisticated application.

\index{Minimizer}
The solution to this problem is using a local $n$-dimensional minimizer instead of a grid-based method. It turns out that such a minimizer can include a full $6$-parameter correlation with of the order of $1\, 000$ function calls of {\tt Chi} or {\tt ChiNew}. It is a standard method which can be found in every good book for standard numerical calculation routines. Thus, for each point on the projection axis/plane, one can obtain a result within about $10$ to $30$ seconds on a modern computer, which means that the complete measurement precision for one fixed true parameter set can be obtained in as much as $10$ to $15$ minutes. One can easily imagine that such a minimizer makes more sophisticated applications possible with the help of overnight calculations, such as showing the dependencies on the true parameter values.

This approach also has a major disadvantage: One can not simply program a robust grid-based code and let it run, since using a local minimizer always means that one may end up in an unwanted local minimum and not in the investigated one. Thus, one has to use some (analytical or numerical) knowledge on the topology of the fit manifold and start the local minimizer close enough to the investigated solution. Fortunately, this can be done quite straightfoward in most cases, since the structure of the neutrino oscillation formulas does not cause very complicated topologies of the fit manifolds. Especially, the are plenty of analytical discussions of this issue, which means that one can implicitely use this knowledge to obtain better predictions for the measurement performances. Note that, since one can easily find the global fit minimum at the best-fit values, any solution found with the local minimizer makes the measurement performance worse. Thus, one can only run the danger to obtain a too optimistic solution if one does not find the other local minima below the chosen confidence level.

\index{Priors} \index{Input errors} \index{Starting values}
In many cases, the fit manifold is restricted by the knowledge from earlier experiments. For example, the knowledge on the solar parameters will in most cases be supplied by the solar neutrino experiments. If the external precision of a parameter is at the time of the measurement better than the one of the experiment itself, one has to impose some external knowledge on this parameter. This external knowledge may reduce the $n$-dimensional fit manifold in the respective direction. In the most extreme case, keeping all parameters but the measured one fixed in the analysis means that all parameters are determined externally with infinitively high precisions. Thus, using the projection method on the axis/plane of interest is a reasonable approach. The inclusion of external input in \GLOBES\ is done by the use of Gaussian {\em priors}: We assume that an external measurement has determined the measured parameter to be at the central value (called {\em starting value}) with a $1 \sigma$ Gaussian error (called {\em input error}). The explicit definition of these priors will be shown in the next section.

\section{The treatment of external input}

\index{External input}
It is one of the strengths of the \GLOBES\ software to use external input to reduce the fit manifold with the knowledge from external (eariler) measurements. The treatment of external input is done by the addition of Gaussian {\em priors} to the final\footnote{After the systematics minimization and after all $\chi^2$'s are added for all channels} $\chi^2$-function  and the minimization over the respective parameters. For example, for the matter density, one obtains as the minimized $\chi^2_F$ after minimzation over $\rho$
\be
 \chi^2_F = \underset{\rho}{\mathrm{min}} \left( \chi^2(\rho) + \frac{(\rho - \rho^0)^2}{\sigma_\rho^2} \right).
\label{equ:priors}
\ee
In practice, this minimzation is done simultaneously over all priors and free oscillation parameters, but this example serves as a very simple illustration. In \equ{priors}, $\rho^0$ is the {\em starting value} of the prior, and $\sigma_\rho$ the $1 \sigma$ absolute {\em input error}. Thus, it is assumed that an external measurement has determined the matter density with a precision (input error) $\sigma_\rho$ at the central value $\rho^0$. Usually, the starting value corresponds to the best-fit value and the input error to the $1 \sigma$ half width of the external measurement. For the matter density, $\rho^0$ can be set to the average matter density $\bar{\rho}$ and $\sigma_\rho$ to the matter density uncertainty. Since \GLOBES\ may also use a matter density profile, it actually uses a scaling factor $\hat\rho$ instead of the average matter density (see last section), \ie, $\rho^0=1.0$ is the central value in either case. Thus, $\sigma_\rho$ directly correponds to the uncertainty of this scaling factor. For instance, using the PREM (``Preliminary Reference Earth Model'') profile, $\rho^0 = 1.0$ and $\sigma_\rho = 0.05$ is a conservative estimate of the PREM profile uncertainty.  \index{PREM profile}

In principle, one can set the priors for the matter density and all oscillation parameters. For example, if the disappearance channels of the experiment determine the leading oscillation parameters, once can set very large values for the input errors ($\sigma$'s). If, however, earlier external measurements provide better information, one can set their absolute precisions with the input errors. The starting values are usually set to the best-fit values. In some cases, it may be necessary to adjust them, such as for $\ldm$ and the negative mass hierarchy to $\rho^0_{\ldm} = - |\ldm|$ if some external precision on $| \ldm |$ is imposed and one is investigating the negative-sign solution. In other cases, minor modifications of the starting values can cause a faster convergence of the algorithm.
In either case, two function have to be called {\em before the usage of any minimizer}:
\begin{function}
\index{{\tt SetStartingValues}}
{\tt SetStartingValues}$(\{\rho^0_{\theta_{12}}, \, \rho^0_{\theta_{13}}, \, \rho^0_{\theta_{23}}, \, \rho^0_{\deltacp}, \, \rho^0_{\sdm}, \, \rho^0_{\ldm}, \, \rho^0_{\hat\rho} \})$ sets the starting values for all of the following minimizer calls.
\end{function}
\begin{function}
\index{{\tt SetInputErrors}}
{\tt SetInputErrors}$(\{\sigma_{\theta_{12}}, \, \sigma_{\theta_{13}}, \, \sigma_{\theta_{23}}, \, \sigma_{\deltacp}, \, \sigma_{\sdm}, \, \sigma_{\ldm}, \, \sigma_{\hat\rho} \})$ sets the input errors for all of the following minimizer calls.
\end{function}
Both functions may take one matter density parameter or as many as there are experiments. Since the assumptions about the matter density profile are usually similar for the loaded experiments, using only one matter density parameter is a useful tool to apply the same starting value  and input error to all loaded experiments.
Eventually, a typical initialization of the external input may look like this:
\begin{quote}
{\tt
SetStartingValues(\{th12, th13, th23, dcp, sdm, ldm, 1.0\}); \\
SetInputErrors(\{th12*0.1, 10, 10, 10, sdm*0.1, ldm, 0.05\}); 
}
\end{quote}
In this example, the starting values are set to the best-fit values. The input errors for $\theta_{13}$, $\theta_{23}$, $\deltacp$, and $\ldm$ are kept large, since the experiment measures these parameters itself. However, some precision on $\ldm$ is imposed to avoid ending up in the negative-sign solution. The solar parameters $\theta_{12}$ and $\sdm$ are assumed to be known with $10\%$ precision each.\footnote{In fact, accelerator-based long-baseline experiments are only sensitive to the product $\sin 2 \theta_{12} \cdot \sdm$, which means that these errors effectively add up to an error of this product.} Finally, the matter density uncertainties are assumed to have an amplitude of $5\% \,  \bar\rho$.
 
\example{Projection of two- and $n$-dimensional manifold onto $\stheta$-axis}{
\label{ex:corrproj}
\index{Projection of manifold}
\index{Two-parameter correlation}
\index{Multi-parameter correlation}

This example demonstrates how to use  {\tt ChiTheta} to project the fit manifold onto the $\stheta$-axis, \ie, how one can include correlations. We compute two sets of data: one for keeping all parameters but $\deltacp$ fixed (two-parameter correlations), and one for keeping all parameters free (multi-parameter correlation), but some external input for the solar parameters and $\rho$. Note that fixing all parameters but $\deltacp$ corresponds to imposing external knowledge on these parameters.

\begin{quote}
{\tt {\footnotesize
/\% Experiment initialization, set reference rate vector: \%/ \\
\mbox{ClearExp(); InitExperiment("{\tt NuFact2.exp}"); SetRunningTime(0,4.0); }\\
th12=arcsin(sqrt(0.8))/2; sdm=7e-5; th23=3.14/4; ldm=2e-3; \\
th13=arcsin(sqrt(0.001))/2; dcp=3.14/2; \\
\mbox{SetVacuumParameters(\{th12, th13, th23, dcp, sdm, ldm\}); SetRates();}\\
\\
/\%  Compute chi-square list with all but dcp fixed: \%/ \\
SetStartingValues(\{th12, th13, th23, dcp, sdm, ldm, 1.0\}); \\
\mbox{SetInputErrors(\{th12*0.001, 10, th23*0.001, 10, sdm*0.001, ldm*0.001, 0.001\});} \\
for (float x=-4; x<-2; x=x+2/20) \\
\mbox{\hspace*{0.5cm} Print(\{x,ChiDelta(x,\{th12, th13, th23, dcp, sdm, ldm, 1.0\}) \}); }\\
\\
/\% Compute chi-square list with all parameters free: \%/ \\
\mbox{/\% (but: 10\% prec. for solar params, 5\% for matter density) \%/} \\
SetStartingValues(\{th12, th13, th23, dcp, sdm, ldm, 1.0\}); \\
SetInputErrors(\{th12*0.1, 10, 10, 10, sdm*0.1, ldm, 0.05\}); \\
for (float x=-4; x<-2; x=x+2/20) \\
\mbox{\hspace*{0.5cm} Print(\{x,ChiDelta(x,\{th12, th13, th23, dcp, sdm, ldm, 1.0\}) \});}
}}
\end{quote}
The two lists of data then represent the $\stheta$ precisions with two-parameter correlations (gray-shaded) and multi-parameter correlations (arrows):
\begin{center}
\colorbox{white}{\includegraphics[width=6cm]{projallex}}

\vspace*{0.1cm}

\footnotesize{(Same parameters as on page~\pageref{ex:corrth13dcp} and in \figu{projex}, but 1 d.o.f.)}
\end{center}
}

\section[Projection onto the $\stheta$-axis or $\deltacp$-axis]{Projection onto the $\boldsymbol{\stheta}$- or $\boldsymbol{\deltacp}$-axis}
\index{Projection onto axis}

\begin{figure}[t]
\begin{center}
\includegraphics[width=16cm]{projex}
\end{center}
\mycaption{\label{fig:projex} Left plot: The correlation between $\stheta$ and $\deltacp$ as calculated in the example on page~\pageref{ex:corrth13dcp}, but for 1 d.o.f. only. Right plot: The $\chi^2$-value of the projection onto the $\stheta$-axis as function of $\stheta$. The projection onto the  $\stheta$-axis is obtained by finding the minimum $\chi^2$-value for each fixed value of $\stheta$ in the left-hand plot, \ie, along the gray vertical lines. The thick gray curve marks the position of these minima in the left-hand plot. The arrows mark the obtained fit ranges for $\stheta$ at the $3 \sigma$ confidence level (1 d.o.f.), \ie , the precision of $\stheta$.}
\end{figure}

The projection onto the $\stheta$- (or $\deltacp$-) axis is performed by fixing $\stheta$ (or $\deltacp$) and minimizing the $\chi^2$-function over all free fit parameters and the matter densities. We illustrate this method at the example of the projection of the two-dimensional manifold in the $\stheta$-$\deltacp$-plane onto the $\stheta$-axis in \figu{projex}. In this figure, the left-hand plot shows the correlation in the $\stheta$-$\deltacp$-plane computed with {\tt Chi} or {\tt SingleChi}. The right-hand plot shows the projection of this two-dimensional manifold onto the $\stheta$ axis by minimizing $\chi^2$ over $\deltacp$. In this simple example, the minimization is done along the vertical gray lines in the left hand plot. The obtained minima are located on the thick gray curve, which means the the right-hand plot represents the $\chi^2$-value along this curve. In fact, one can easily see that one obtains the correct projected $3 \sigma$ errors in this example (\cf, arrows). This figure illustrates the projection of a two-parameter correlation. In general, the full $n$-parameter correlation is treated similarly by the simultaneous (local) minimization over all free fit parameters. The example on page~\pageref{ex:corrproj} demonstrates how one can obtain \figu{projex} (right) with keeping all parameters but $\deltacp$ fixed, as well as how one can inlcude the full $n$-parameter correlation with external input. It also demonstrates how these two compare to each other.

One mentioned disadvantage of the local minimizer is the possibility to end up in a local minimum. Usually it works very well to start the minimizer close to the best-fit values. In the example in \figu{projex}, the minimizer is always started at $\deltacp=90^\circ$ and finds its way to the appropriate minimum. In some cases, however, the topology may be more difficult and the true minimum is not correctly found. A strong indication for such a situation are discontinuities in the projected $\chi^2$-function, where the minimizer jumps from one minimum to the other. In such a case, the starting point of the minimizer has to be adjusted to help it find the true minimum. In other cases, the convergence of the minimizer may be infinitively small. Then it usually helps to start the minimizer somewhat off the best-fit values. The following functions are the simplest minimizers provided by \GLOBES :
\begin{function}
\index{{\tt ChiTheta}}
{\tt ChiTheta}$( \theta_{13}, \, \{ \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \, \ldm, \, \hat{\rho_1}, \,  \hdots ,  \,\hat{\rho_n} \})$ returns the projection onto the $\theta_{13}$-axis for all experiments. The parameters are the fixed value of $\theta_{13}$ and the starting point of the minimizer including all starting values for the matter density scaling factors (without $\theta_{13}$, which is fixed). The return value is a list $\{ \chi^2, \, \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \, \ldm, \, \hat{\rho_1}, \, \hdots , \, \hat{\rho_n} , \, N_{\mathrm{Iter}} \}$ with the minimum $\chi^2$ found, the coordinates of the local minimum (without $\theta_{13}$), and the number of iterations $N_{\mathrm{Iter}}$ used by the minimizer (number of function calls of {\tt Chi}).
\end{function}
\begin{function}
\index{{\tt SingleChiTheta}}
{\tt SingleChiTheta}$( \theta_{13}, \, \{ \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \, \ldm,  \, \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}})$ works similar to {\tt ChiTheta}, but only for one of the loaded experiments $N_{\mathrm{exp}}$. It returns the list $\{ \chi^2, \, \theta_{12}, \,  \theta_{23}, \, \deltacp , \, \sdm , \, \ldm, \, \hat{\rho}_{N_{\mathrm{exp}}} , \, N_{\mathrm{Iter}} \}$.
\end{function}
\begin{function}
\index{{\tt ChiDelta}}
{\tt ChiDelta}$( \deltacp, \, \{ \theta_{12}, \, \theta_{13}, \, \theta_{23}, \, \sdm , \, \ldm, \, \hat{\rho_1}, \,  \hdots ,  \,\hat{\rho_n} \})$ returns the projection onto the $\deltacp$-axis for all experiments. The parameters are the fixed value of $\deltacp$ and the starting point of the minimizer including all starting values for the matter density scaling factors (without $\deltacp$, which is fixed). The return value is a list $\{ \chi^2, \, \theta_{12}, \, \theta_{13}, \, \theta_{23}, \, \sdm , \, \ldm, \, \hat{\rho_1}, \, \hdots , \, \hat{\rho_n} , \, N_{\mathrm{Iter}} \}$ with the minimum $\chi^2$ found, the coordinates of the local minimum (without $\deltacp$), and the number of iterations $N_{\mathrm{Iter}}$ used by the minimizer (number of function calls of {\tt Chi}).
\end{function}
\begin{function}
\index{{\tt SingleChiDelta}}
{\tt SingleChiDelta}$( \deltacp, \, \{ \theta_{12}, \, \theta_{13}, \, \theta_{23}, \, \sdm , \, \ldm, \,  \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}})$ works similar to {\tt ChiDelta}, but only for one of the loaded experiments $N_{\mathrm{exp}}$. It returns the list $\{ \chi^2, \, \theta_{12}, \,  \theta_{13}, \,  \theta_{23}, \, \sdm , \, \ldm, \, \hat{\rho}_{N_{\mathrm{exp}}} , \, N_{\mathrm{Iter}} \}$.
\end{function}
All of these function have the same parameter structure: The fixed parameter is not transferred in the list, but as a the first separate parameter. The number of matter density scaling factors corresponds to the number of experiments used, since each experiment may face other matter density conditions. Note that before any of these function calls, {\tt SetStartingValues} and {\tt SetInputErrors} have to be used at least once. In addition, note that the resulting $\chi^2$ of {\tt ChiTheta} (or {\tt ChiDelta}) is not the sum of the $\chi^2$-values over all {\tt Single}-functions of all experiments anymore. This has two reasons: First, the topology of the fit manifold is altered by the addition of $\chi^2$-values of different experiments. Thus, after the minimization, the position of the minimum can be different to the ones of the individual experiments. Second, the priors for the external knowledge on the parameters are only added once -- independent of the number of experiments. A simple application of {\tt ChiTheta} can be found in the example on page~\pageref{ex:corrproj}. 

The return values of these functions do not only contain the minimum $\chi^2$-value found, but also the position of the minimum. This information can often be valuable, since one can often quickly locate irregularities: If one of the parameters is far off the best-fit value, the minimzer may have ended up in a local unwanted minimum. For instance, a negative value of $\ldm$ (with a positive best-fit value) indicates that the minimizer ended up in the opposite-sign solution. Another possibility is that the experiment may not be able to determine the measured parameter at all without external knowledge about the parameter far off its best-fit value. In both cases, an externally imposed precision on the run-off parameter can help to solve the problem. 

\section[Projection onto any hyperplane]{Projection onto any  hyperplane}
\index{Projection onto hyperplane}

In general, one can show the measurement result in any $k$-dimensional hyperplane, where $k$ is smaller than the dimension of the parameter space $n$, and thus the dimension of the fit manifold. In this case, $k$ parameters are fixed and $n-k$ parameters are minimized over. One such example is the projection of the fit manifold onto the $\stheta$-$\deltacp$-plane, \ie, $k=2$ here. This projection can be performed with the following functions:
\begin{function}
\index{{\tt ChiThetaDelta}}
{\tt ChiThetaDelta}$(\theta_{13}, \, \deltacp, \, \{ \theta_{12}, \, \theta_{23},  \, \sdm , \, \ldm, \,   \hat{\rho_1}, ... , \hat{\rho_n} \})$ returns the list  $\{ \chi^2, \, \theta_{12}, \, \theta_{23}, \, \sdm , \, \ldm,  \, \hat{\rho_1}, \, \hdots , \, \hat{\rho_n} , \, N_{\mathrm{Iter}} \}$ for the projection into the $\theta_{13}$-$\deltacp$-plane for all experiments.
\end{function}
\begin{function}
\index{{\tt SingleChiThetaDelta}}
{\tt SingleChiThetaDelta}$( \theta_{13}, \, \deltacp, \, \{ \theta_{12}, \, \theta_{23}, \, \sdm , \, \ldm, \,   \hat{\rho}_{N_{\mathrm{exp}}} \}, \, N_{\mathrm{exp}})$ returns the list $\{ \chi^2, \, \theta_{12}, \,   \theta_{23},  \, \sdm , \, \ldm, \, \hat{\rho}_{N_{\mathrm{exp}}} ,  \, N_{\mathrm{Iter}} \}$ for the projection into the $\theta_{13}$-$\deltacp$-plane for one experiment $N_{\mathrm{exp}}$.
\end{function}
These functions work analogously to the ones in the last section. They can, for example, be used to obtain a figure similar to \figu{projex}, left. However, the result would not be a two-dimensional cut through the fit-manifold, but a two-dimensional projection. Though the running time for one call of these functions is somewhat shorter than the one for the $\stheta$- or $\deltacp$-projections, one has to compute a two-dimensional array for such a figure (instead of a one-dimensional list). Therefore, the overall computational effort is much higher.

In principle, one can also use three- or more-dimensional projections. In addition, one may want to use any other set of parameters for single- or two-parameter projections. The functions {\tt ChiNP} and {\tt SingleChiNP} are designed for this purpose:

FUNCTIONS TO BE DEFINED. (WORK IN PROGRESS).

\chapter{Finding degenerate solutions}
\index{Degenerate solutions}

In the last chapter, we introduced the projection of any set of $k$ parameter onto any $n-k$ dimensional hyperplane, which was done by the minimization over the $k$ free fit parameters. Similarly, one can minimize over {\em all} $n$ parameters to find the local minimum close to any starting point. This approach is very useful for the exact numerical location of a degenerate if its approximate position is known. For the determination of the approximate positon, one can use analytical approaches, such as in \Refs~TO BE ENTERED, or an educated guess. 
Though the usage of the all-parameter minimizers is quite simple, one should keep in mind that they are local minimizers. Therefore, one may need a very sophisticated application software to actually find all degenerate solutions.

\example{Finding the $\mathrm{sgn}(\ldm)$-degeneracy}{
\label{ex:sgndeg}

In many cases, one can find the $\mathrm{sgn}(\ldm)$-degeneracy with {\tt ChiAll}: One lets the local minimizer start at the position of the suspected solution at the opposite sign of $\ldm$.  The following example corresponds to finding the degenerate solution for the example on page~\pageref{ex:corrth13dcp}.
\begin{quote}
{\tt
{\footnotesize
/\% Experiment initialization: \%/ \\
ClearExp(); InitExperiment("{\tt NuFact2.exp}"); SetRunningTime(0,4.0); \\
\\
/\% Set reference rate vector: \%/ \\
th12=arcsin(sqrt(0.8))/2; sdm=7e-5; th23=3.14/4; ldm=2e-3; \\
th13=arcsin(sqrt(0.001))/2; dcp=3.14/2; \\
\mbox{SetVacuumParameters(\{th12, \, th13, \, th23, \, dcp, \, sdm, \, ldm\});  SetRates();} \\
\\
/\% Find negative-sign solution: \%/ \\
SetStartingValues(\{th12, \, th13, \, th23, \, dcp, \, sdm, \, -ldm, \, 1.0\}); \\
SetInputErrors(\{th12*0.1, \, 10, \, 10, \, 10, \, sdm*0.1, \, ldm/3, \, 0.05\}); \\
d = ChiAll(\{th12, \, th13, \, th23, \, dcp, \, sdm, \, ldm, \, 1.0\}); \\
\\
/\% Compute chi-square matrix: \%/ \\
for (float x=-4; x<-2; x=x+2/50) \\
\hspace*{0.5cm} for (float y=0; y<200; y=y+200/50) \{ \\
\hspace*{1cm} theth13 = arcsin(sqrt(10$\hat{\, \, \,}$x))/2; \\
\mbox{\hspace*{1cm} Print(\{x,y,Chi(\{d[2], theth13,  d[4],  y, d[6], d[7], d[8]\}) \}) \};}
}
}
\end{quote}

The resulting matrix can then be plotted as a contour plot in addition to the original solution (2 d.o.f., gray contours):
\begin{center}
\colorbox{white}{\includegraphics[width=7.5cm]{correntex}}
\end{center}

}

\index{All-parameter minimization}
The functions to perform the all-parameter minimization are {\tt ChiAll} and {\tt SingleChiAll}:
\begin{function}
\index{{\tt ChiAll}}
{\tt ChiAll}$(\{ \theta_{13}, \, \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \, \ldm,  \, \hat{\rho_1}, \, \hdots , \, \hat{\rho_n} \})$ finds the local minimum close to the given starting point (list) for all initialized experiments. It returns the list  $\{ \chi^2, \, \theta_{13}, \, \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \,  \ldm,  \, \hat{\rho_1}, \, \hdots , \hat{\rho_n} , \, N_{\mathrm{Iter}} \}$ with the minimum $\chi^2$-value, the actual position of the local minimum, and the number of iterations $N_{\mathrm{Iter}}$ used.
\end{function}
\begin{function}
\index{{\tt SingleChiAll}} 
{\tt SingleChiAll}$( \{ \theta_{13}, \, \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \, \ldm, \,   \hat{\rho}_{N_{\mathrm{exp}}} \}, \, \, N_{\mathrm{exp}})$ finds the local minimum close to the given starting point (list) for the experiment $N_{\mathrm{exp}}$ only. It returns the list
 $\{ \chi^2, \, \theta_{13}, \, \theta_{12}, \, \theta_{23}, \, \deltacp , \, \sdm , \, \ldm, \, \hat{\rho}_{N_{\mathrm{exp}}} ,  \, N_{\mathrm{Iter}} \}$ with the minimum $\chi^2$-value, the actual position of the local minimum, and the number of iterations $N_{\mathrm{Iter}}$ used.
\end{function}
%
Both functions take the suspected position of the local minimum and return its true position. The application of  {\tt SingleChiAll} can be especially usefull for many different experiments evaluated simultaneously: It turns out to be useful to find the positions of the degeneracies for the individual experiments first, and then test all of these with the combination of all experiments in order not to miss a degenerate solution. The example on page~\pageref{ex:sgndeg} illustrates how to locate the $\mathrm{sgn}(\ldm)$-degeneracy and show the corresponding degenerate solution in the $\stheta$-$\deltacp$-plane together with the original solution.
In this case, the position of the degeneracy can be easily guessed to be at the best-fit parameter values but the $\ldm$ inverted. The minimizer then runs off the plane of the best-fit parameters into the local minimum. It is very important to take into account the position of the degeneracy off this plane, since the actual $\chi^2$ in the minimum is certainly lower than on the plane of the best-fit parameter values. Thus, the degeneracy may not even appear at the chosen confidence level on the plane, but it does appear at the true minimum. The two cuts\footnote{The discussed figure on page~\pageref{ex:sgndeg} is produced by  {\tt Chi} and thus only represents a cut through the fit manifold. For the projection including correlations, one may rather want to use {\tt ChiThetaDelta}.} through the fit manifold shown in the figure on page~\pageref{ex:sgndeg} therefore do not have the same oscillation parameter values (except from the ones shown in the figure). 

In practice, a number of tricks can be useful for the treatment of degenerate solutions:
\begin{description}
\item[Minimum $\boldsymbol{\chi^2}$ larger than threshold.] If a located degeneracy has a minimum $\chi^2$ larger than the corresponding confidence level threshold for the discussed quantity of interest, the degeneracy can be immediately ignored. This saves a lot of computation time.
\item[Locating degeneracies with more complicated topologies.] For more complicated topologies, such as for neutrino factories, it is often useful to use multi-step location procedures or analytical knowledge. For example, for a numerical procedure, one may first of all switch off the systematics and keep $\stheta$ or $\deltacp$ fixed, \ie, use {\tt SingleChiTheta} or {\tt SingleChiDelta}, where $\stheta$ or $\deltacp$ is fixed to the best-fit value. The result can then be used as a starting point for {\tt SingleChiAll} with the systematics switched on again. In addition to switching off the systematics, it can be useful to reduce the input errors during the first steps in order to make the minimizer not to run away too much from the true solution.
\item[Finding degeneracies with multiple experiments.] For multiple experiments, the degeneracies should be located for each of the individual experiments first. Then, all of the found degeneracies below the threshold can be tested for the combination of experiments.  
\end{description}
Finally, note that any degenerate solution below the confidence level threshold which can not be located makes the result appear better than it actually is. Thus, one should be careful with the determination of the degenerate solutions.

\chapter{Obtaining low-level information}

\bi
\item
 Obtaining rate vectors
\item
 Obtaining fluxes/cross sections etc.
\item
 ``Check''-functions
\ei

\chapter{Changing experiment parameters at running time}

\bi
\item
 Baseline, Target mass, Source power, running time
\item
 Matter density profile
\item
 Threshold function, efficiencies etc.
\ei