/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20010222-1507 (Alpha 3)
 * 
 * Portions Copyright (c) 1995-2000
 * The University of Utah, The Regents of the University of California, and
 * The University of Chicago.  Permission is hereby granted to use, modify, 
 * and distribute this file in any manner provided this notice remains intact.
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/* $Header: /home/lin/globes/cvs-noaccess/Projects/GLOBES/Distribution/globes/globes_wrap.c,v 1.1 2004/10/11 13:50:52 globes Exp $ */
/* Implementation : PERL 5 */

#define SWIGPERL
#define SWIGPERL5
#ifdef __cplusplus
/* Needed on some windows machines---since MS plays funny
   games with the header files under C++ */
#include <math.h>
#include <stdlib.h>
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

/* Get rid of free and malloc defined by perl */
#undef free
#undef malloc

#include <string.h>
#ifdef __cplusplus
}
#endif
/* Definitions for compiling Perl extensions on a variety of machines */


#if defined(WIN32) || defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef PERL_OBJECT
#define MAGIC_PPERL  CPerlObj *pPerl = (CPerlObj *) this;
#define MAGIC_CAST   (int (CPerlObj::*)(SV *, MAGIC *))
#define SWIGCLASS_STATIC 
#else
#define MAGIC_PPERL
#define MAGIC_CAST
#define SWIGCLASS_STATIC static
#endif

#if defined(WIN32) && defined(PERL_OBJECT) && !defined(PerlIO_exportFILE)
#define PerlIO_exportFILE(fh,fl) (FILE*)(fh)
#endif

/* Modifications for newer Perl 5.005 releases */

#if !defined(PERL_REVISION) || ((PERL_REVISION >= 5) && ((PERL_VERSION < 5) || ((PERL_VERSION == 5) && (PERL_SUBVERSION < 50))))
#ifndef PL_sv_yes
#define PL_sv_yes sv_yes
#endif
#ifndef PL_sv_undef
#define PL_sv_undef sv_undef
#endif
#ifndef PL_na
#define PL_na na
#endif
#endif

/******************************************************************************
 * Pointer type-checking code
 *****************************************************************************/

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SWIG_NOINCLUDE
extern void SWIG_MakePtr(char *, void *, char *);
#ifndef PERL_OBJECT
extern void SWIG_RegisterMapping(char *, char *, void *(*)(void *));
#else
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl,a,b,c);
extern void _SWIG_RegisterMapping(CPerlObj *,char *, char *, void *(*)(void *),int);
#endif
#ifndef PERL_OBJECT
extern char *SWIG_GetPtr(SV *, void **, char *);
#else
extern char *_SWIG_GetPtr(CPerlObj *, SV *, void **, char *);
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
#endif

#else

#ifdef SWIG_GLOBAL
#define SWIGSTATICRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGSTATICRUNTIME(a) static a
#endif

/* These are internal variables.   Should be static */

typedef struct SwigPtrType {
  char               *name;
  int                 len;
  void               *(*cast)(void *);
  struct SwigPtrType *next;
} SwigPtrType;

/* Pointer cache structure */

typedef struct {
  int                 stat;               /* Status (valid) bit             */
  SwigPtrType        *tp;                 /* Pointer to type structure      */
  char                name[256];          /* Given datatype name            */
  char                mapped[256];        /* Equivalent name                */
} SwigCacheType;

static int SwigPtrMax  = 64;           /* Max entries that can be currently held */
static int SwigPtrN    = 0;            /* Current number of entries              */
static int SwigPtrSort = 0;            /* Status flag indicating sort            */
static SwigPtrType *SwigPtrTable = 0;  /* Table containing pointer equivalences  */
static int SwigStart[256];             /* Table containing starting positions    */

/* Cached values */

#define SWIG_CACHESIZE  8
#define SWIG_CACHEMASK  0x7
static SwigCacheType SwigCache[SWIG_CACHESIZE];  
static int SwigCacheIndex = 0;
static int SwigLastCache = 0;

/* Sort comparison function */
static int swigsort(const void *data1, const void *data2) {
	SwigPtrType *d1 = (SwigPtrType *) data1;
	SwigPtrType *d2 = (SwigPtrType *) data2;
	return strcmp(d1->name,d2->name);
}

/* Binary Search function */
static int swigcmp(const void *key, const void *data) {
  char *k = (char *) key;
  SwigPtrType *d = (SwigPtrType *) data;
  return strncmp(k,d->name,d->len);
}

/* Register a new datatype with the type-checker */

#ifndef PERL_OBJECT
SWIGSTATICRUNTIME(void) 
SWIG_RegisterMapping(char *origtype, char *newtype, void *(*cast)(void *)) {
#else
#define SWIG_RegisterMapping(a,b,c) _SWIG_RegisterMapping(pPerl, a,b,c)
SWIGSTATICRUNTIME(void)
_SWIG_RegisterMapping(CPerlObj *pPerl, char *origtype, char *newtype, void *(*cast)(void *)) {
#endif

  int i;
  SwigPtrType *t = 0, *t1;

  if (!SwigPtrTable) {     
    SwigPtrTable = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrN = 0;
  }
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrTable = (SwigPtrType *) realloc(SwigPtrTable,SwigPtrMax*sizeof(SwigPtrType));
  }
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrTable[i].name,origtype) == 0) {
      t = &SwigPtrTable[i];
      break;
    }
  if (!t) {
    t = &SwigPtrTable[SwigPtrN];
    t->name = origtype;
    t->len = strlen(t->name);
    t->cast = 0;
    t->next = 0;
    SwigPtrN++;
  }
  while (t->next) {
    if (strcmp(t->name,newtype) == 0) {
      if (cast) t->cast = cast;
      return;
    }
    t = t->next;
  }
  t1 = (SwigPtrType *) malloc(sizeof(SwigPtrType));
  t1->name = newtype;
  t1->len = strlen(t1->name);
  t1->cast = cast;
  t1->next = 0;
  t->next = t1;
  SwigPtrSort = 0;
}

/* Make a pointer value string */

SWIGSTATICRUNTIME(void) 
SWIG_MakePtr(char *_c, const void *_ptr, char *type) {
  static char _hex[16] =
  {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
   'a', 'b', 'c', 'd', 'e', 'f'};
  unsigned long _p, _s;
  char _result[20], *_r;    /* Note : a 64-bit hex number = 16 digits */
  _r = _result;
  _p = (unsigned long) _ptr;
  if (_p > 0) {
    while (_p > 0) {
      _s = _p & 0xf;
      *(_r++) = _hex[_s];
      _p = _p >> 4;
    }
    *_r = '_';
    while (_r >= _result)
      *(_c++) = *(_r--);
  } else {
    strcpy (_c, "NULL");
  }
  if (_ptr)
    strcpy (_c, type);
}

/* Function for getting a pointer value */

#ifndef PERL_OBJECT
SWIGSTATICRUNTIME(char *) 
SWIG_GetPtr(SV *sv, void **ptr, char *_t)
#else
#define SWIG_GetPtr(a,b,c) _SWIG_GetPtr(pPerl,a,b,c)
SWIGSTATICRUNTIME(char *)
_SWIG_GetPtr(CPerlObj *pPerl, SV *sv, void **ptr, char *_t)
#endif
{
  char temp_type[256];
  char *name,*_c;
  int  len,i,start,end;
  IV   tmp;
  SwigPtrType *sp,*tp;
  SwigCacheType *cache;

  /* If magical, apply more magic */

  if (SvGMAGICAL(sv))
    mg_get(sv);

  /* Check to see if this is an object */
  if (sv_isobject(sv)) {
    SV *tsv = (SV*) SvRV(sv);
    if ((SvTYPE(tsv) == SVt_PVHV)) {
      MAGIC *mg;
      if (SvMAGICAL(tsv)) {
	mg = mg_find(tsv,'P');
	if (mg) {
	  SV *rsv = mg->mg_obj;
	  if (sv_isobject(rsv)) {
	    tmp = SvIV((SV*)SvRV(rsv));
	  }
	}
      } else {
	return "Not a valid pointer value";
      }
    } else {
      tmp = SvIV((SV*)SvRV(sv));
    }
    if (!_t) {
      *(ptr) = (void *) tmp;
      return (char *) 0;
    }
  } else if (! SvOK(sv)) {            /* Check for undef */
    *(ptr) = (void *) 0;
    return (char *) 0;
  } else if (SvTYPE(sv) == SVt_RV) {       /* Check for NULL pointer */
    *(ptr) = (void *) 0;
    if (!SvROK(sv)) 
      return (char *) 0;
    else
      return "Not a valid pointer value";
  } else {                                 /* Don't know what it is */
      *(ptr) = (void *) 0;
      return "Not a valid pointer value";
  }
  if (_t) {
    /* Now see if the types match */      

    if (!sv_isa(sv,_t)) {
      _c = HvNAME(SvSTASH(SvRV(sv)));
      if (!SwigPtrSort) {
	qsort((void *) SwigPtrTable, SwigPtrN, sizeof(SwigPtrType), swigsort);  
	for (i = 0; i < 256; i++) {
	  SwigStart[i] = SwigPtrN;
	}
	for (i = SwigPtrN-1; i >= 0; i--) {
	  SwigStart[SwigPtrTable[i].name[0]] = i;
	}
	for (i = 255; i >= 1; i--) {
	  if (SwigStart[i-1] > SwigStart[i])
	    SwigStart[i-1] = SwigStart[i];
	}
	SwigPtrSort = 1;
	for (i = 0; i < SWIG_CACHESIZE; i++)  
	  SwigCache[i].stat = 0;
      }
      /* First check cache for matches.  Uses last cache value as starting point */
      cache = &SwigCache[SwigLastCache];
      for (i = 0; i < SWIG_CACHESIZE; i++) {
	if (cache->stat) {
	  if (strcmp(_t,cache->name) == 0) {
	    if (strcmp(_c,cache->mapped) == 0) {
	      cache->stat++;
	      *ptr = (void *) tmp;
	      if (cache->tp->cast) *ptr = (*(cache->tp->cast))(*ptr);
	      return (char *) 0;
	    }
	  }
	}
	SwigLastCache = (SwigLastCache+1) & SWIG_CACHEMASK;
	if (!SwigLastCache) cache = SwigCache;
	else cache++;
      }

      start = SwigStart[_t[0]];
      end = SwigStart[_t[0]+1];
      sp = &SwigPtrTable[start];
      while (start < end) {
	if (swigcmp(_t,sp) == 0) break;
	sp++;
	start++;
      }
      if (start > end) sp = 0;
      while (start <= end) {
	if (swigcmp(_t,sp) == 0) {
	  name = sp->name;
	  len = sp->len;
	  tp = sp->next;
	  while(tp) {
	    if (tp->len >= 255) {
	      return _c;
	    }
	    strcpy(temp_type,tp->name);
	    strncat(temp_type,_t+len,255-tp->len);
	    if (sv_isa(sv,temp_type)) {
	      /* Get pointer value */
	      *ptr = (void *) tmp;
	      if (tp->cast) *ptr = (*(tp->cast))(*ptr);

	      strcpy(SwigCache[SwigCacheIndex].mapped,_c);
	      strcpy(SwigCache[SwigCacheIndex].name,_t);
	      SwigCache[SwigCacheIndex].stat = 1;
	      SwigCache[SwigCacheIndex].tp = tp;
	      SwigCacheIndex = SwigCacheIndex & SWIG_CACHEMASK;
	      return (char *) 0;
	    }
	    tp = tp->next;
	  } 
	}
	sp++;
	start++;
      }
      /* Didn't find any sort of match for this data.  
	 Get the pointer value and return the received type */
      *ptr = (void *) tmp;
      return _c;
    } else {
      /* Found a match on the first try.  Return pointer value */
      *ptr = (void *) tmp;
      return (char *) 0;
    }
  } 
  *ptr = (void *) tmp;
  return (char *) 0;
}

#endif
#ifdef __cplusplus
}
#endif






/* Magic variable code */
#ifndef PERL_OBJECT
#define swig_create_magic(s,a,b,c) _swig_create_magic(s,a,b,c)
static void _swig_create_magic(SV *sv, char *name, int (*set)(SV *, MAGIC *), int (*get)(SV *,MAGIC *)) {
#else
#define swig_create_magic(s,a,b,c) _swig_create_magic(pPerl,s,a,b,c)
static void _swig_create_magic(CPerlObj *pPerl, SV *sv, char *name, int (CPerlObj::*set)(SV *, MAGIC *), int (CPerlObj::*get)(SV *, MAGIC *)) {
#endif
  MAGIC *mg;
  sv_magic(sv,sv,'U',name,strlen(name));
  mg = mg_find(sv,'U');
  mg->mg_virtual = (MGVTBL *) malloc(sizeof(MGVTBL));
  mg->mg_virtual->svt_get = get;
  mg->mg_virtual->svt_set = set;
  mg->mg_virtual->svt_len = 0;
  mg->mg_virtual->svt_clear = 0;
  mg->mg_virtual->svt_free = 0;
}

#define SWIG_init    boot_globes

#define SWIG_name   "globes::boot_globes"
#define SWIG_varinit "globes::var_globes_init();"
#ifdef __cplusplus
extern "C"
#endif
#ifndef PERL_OBJECT
SWIGEXPORT(void) SWIG_init (CV* cv);
#else
SWIGEXPORT(void) SWIG_init (CV *cv, CPerlObj *);
#endif
#ifndef PERL_OBJECT
#define swig_setiv(a,b) _swig_setiv(a,b)
static void _swig_setiv(char *name, long value) { 
#else
#define swig_setiv(a,b) _swig_setiv(pPerl,a,b)
static void _swig_setiv(CPerlObj *pPerl, char *name, long value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setiv(sv, (IV) value);
     SvREADONLY_on(sv);
}

#ifndef PERL_OBJECT
#define swig_setnv(a,b) _swig_setnv(a,b)
static void _swig_setnv(char *name, double value) { 
#else
#define swig_setnv(a,b) _swig_setnv(pPerl,a,b)
static void _swig_setnv(CPerlObj *pPerl, char *name, double value) { 
#endif
     SV *sv; 
     sv = perl_get_sv(name,TRUE | 0x2);
     sv_setnv(sv, value);
     SvREADONLY_on(sv);
}


#include "globes.h"
#ifdef PERL_OBJECT
#define MAGIC_CLASS _wrap_globes_var::
class _wrap_globes_var : public CPerlObj {
public:
#else
#define MAGIC_CLASS
#endif
SWIGCLASS_STATIC int swig_magic_readonly(SV *sv, MAGIC *mg) {
    MAGIC_PPERL
    sv = sv; mg = mg;
    croak("Value is read-only.");
    return 0;
}
SWIGCLASS_STATIC int _wrap_set_glb_path_vector(SV* sv, MAGIC *mg) {

    void *_temp;

    MAGIC_PPERL
    mg = mg;
    if (SWIG_GetPtr(sv,(void **) &_temp,"charPtrPtr")) {
        croak("Type error in value of glb_path_vector. Expected charPtrPtr.");
        return(1);
    }
    glb_path_vector = (char **) _temp;
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_glb_path_vector(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) glb_path_vector);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_glb_path_vector_length(SV* sv, MAGIC *mg) {

    void *_temp;

    MAGIC_PPERL
    mg = mg;
    if (SWIG_GetPtr(sv,(void **) &_temp,"size_tPtr")) {
        croak("Type error in value of glb_path_vector_length. Expected size_tPtr.");
        return(1);
    }
    glb_path_vector_length = *((size_t *) _temp);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_glb_path_vector_length(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) &glb_path_vector_length);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_glb_num_of_exps(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    glb_num_of_exps = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_glb_num_of_exps(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) glb_num_of_exps);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_glb_single_experiment_number(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    glb_single_experiment_number = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_glb_single_experiment_number(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) glb_single_experiment_number);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_glb_experiment_list(SV *sv, MAGIC *mg) {

    SV *rsv;

    MAGIC_PPERL
    mg = mg;
    rsv = SvRV(sv);
    sv_setiv(rsv,(IV) glb_experiment_list);
    return 1;
}

SWIGCLASS_STATIC int _wrap_set_glb_rule_number(SV* sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    glb_rule_number = (int ) SvIV(sv);
    return 1;
}

SWIGCLASS_STATIC int _wrap_val_glb_rule_number(SV *sv, MAGIC *mg) {


    MAGIC_PPERL
    mg = mg;
    sv_setiv(sv, (IV) glb_rule_number);
    return 1;
}



#ifdef PERL_OBJECT
};
#endif

XS(_wrap_glbSetVerbosityLevel) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetVerbosityLevel(level);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbSetVerbosityLevel(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbPrintDelimiter) {

    FILE  *_arg0;
    int  _arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbPrintDelimiter(stream,character);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of glbPrintDelimiter. Expected FILEPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    glbPrintDelimiter(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_glbSetIteration) {

    int  _arg1;
    int argvi = 0;
    dXSARGS ;
    glb_params  _result,_arg0;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbSetIteration(in,iter);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbSetIteration. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (glb_params )glbSetIteration(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_params", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetIteration) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetIteration(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbGetIteration. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbGetIteration(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbCopyParams) {

    int argvi = 0;
    dXSARGS ;
    glb_params  _result,_arg0,_arg1;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbCopyParams(source,dest);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbCopyParams. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbCopyParams. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (glb_params )glbCopyParams(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_params", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbDefineParams) {

    double  _arg1,_arg2,_arg3,_arg4,_arg5,_arg6;
    int argvi = 0;
    dXSARGS ;
    glb_params  _result,_arg0;
    cv = cv;
    if ((items < 7) || (items > 7)) 
        croak("Usage: glbDefineParams(in,theta12,theta13,theta23,delta,dms,dma);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbDefineParams. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _arg4 = (double ) SvNV(ST(4));
    _arg5 = (double ) SvNV(ST(5));
    _arg6 = (double ) SvNV(ST(6));
    _result = (glb_params )glbDefineParams(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_params", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbAllocParams) {

    int argvi = 0;
    dXSARGS ;
    glb_params  _result;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbAllocParams();");
    _result = (glb_params )glbAllocParams();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_params", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbFreeParams) {

    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbFreeParams(stale);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbFreeParams. Expected glb_params.");
        XSRETURN(1);
    }
    glbFreeParams(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_glbSetDensityParams) {

    int  _arg2;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;
    glb_params  _result,_arg0;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetDensityParams(in,dens,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbSetDensityParams. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (glb_params )glbSetDensityParams(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_params", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetDensityParams) {

    int  _arg1;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbGetDensityParams(in,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbGetDensityParams. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (double )glbGetDensityParams(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetOscParams) {

    int  _arg2;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;
    glb_params  _result,_arg0;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetOscParams(in,osc,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbSetOscParams. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (double ) SvNV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (glb_params )glbSetOscParams(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_params", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetOscParams) {

    int  _arg1;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbGetOscParams(in,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbGetOscParams. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (double )glbGetOscParams(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbPrintParams) {

    FILE  *_arg0;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg1;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbPrintParams(stream,in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of glbPrintParams. Expected FILEPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbPrintParams. Expected glb_params.");
        XSRETURN(1);
    }
    glbPrintParams(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_glbSetProjectionFlag) {

    glb_projection  _result,_arg0;
    int  _arg1,_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetProjectionFlag(in,flag,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbSetProjectionFlag. Expected glb_projection.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (glb_projection )glbSetProjectionFlag(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_projection", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetProjectionFlag) {

    int  _result,_arg1;
    glb_projection  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbGetProjectionFlag(in,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbGetProjectionFlag. Expected glb_projection.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )glbGetProjectionFlag(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetDensityProjectionFlag) {

    glb_projection  _result,_arg0;
    int  _arg1,_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetDensityProjectionFlag(in,flag,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbSetDensityProjectionFlag. Expected glb_projection.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (glb_projection )glbSetDensityProjectionFlag(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_projection", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetDensityProjectionFlag) {

    int  _result,_arg1;
    glb_projection  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbGetDensityProjectionFlag(in,which);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbGetDensityProjectionFlag. Expected glb_projection.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )glbGetDensityProjectionFlag(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbCopyProjection) {

    glb_projection  _result,_arg0,_arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbCopyProjection(source,dest);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbCopyProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_projection")) {
        croak("Type error in argument 2 of glbCopyProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    _result = (glb_projection )glbCopyProjection(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_projection", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbDefineProjection) {

    glb_projection  _result,_arg0;
    int  _arg1,_arg2,_arg3,_arg4,_arg5,_arg6;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 7) || (items > 7)) 
        croak("Usage: glbDefineProjection(in,theta12,theta13,theta23,delta,dms,dma);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbDefineProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _result = (glb_projection )glbDefineProjection(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_projection", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbAllocProjection) {

    glb_projection  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbAllocProjection();");
    _result = (glb_projection )glbAllocProjection();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_projection", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbFreeProjection) {

    glb_projection  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbFreeProjection(stale);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbFreeProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    glbFreeProjection(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_glbPrintProjection) {

    FILE  *_arg0;
    glb_projection  _arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbPrintProjection(stream,in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of glbPrintProjection. Expected FILEPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_projection")) {
        croak("Type error in argument 2 of glbPrintProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    glbPrintProjection(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_glbSetOscillationParameters) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetOscillationParameters(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbSetOscillationParameters. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbSetOscillationParameters(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetOscillationParameters) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetOscillationParameters(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbGetOscillationParameters. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbGetOscillationParameters(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbVacuumProbability) {

    int  _arg0,_arg1,_arg2;
    double  _result,_arg3,_arg4;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: glbVacuumProbability(pl,pm,panti,pen,plength);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _arg4 = (double ) SvNV(ST(4));
    _result = (double )glbVacuumProbability(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbProfileProbability) {

    int  _arg0,_arg1,_arg2,_arg3;
    double  _result,_arg4;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: glbProfileProbability(exp,initial_flavour,final_flavour,panti,energy);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (double ) SvNV(ST(4));
    _result = (double )glbProfileProbability(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbXSection) {

    int  _arg0,_arg1,_arg3,_arg4;
    double  _result,_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: glbXSection(experiment,xsec_ident,energy,flavour,anti);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _result = (double )glbXSection(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiSys) {

    int  _arg1,_arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiSys(in,experiment,rule);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiSys. Expected glb_params.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiSys(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetStartingValues) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetStartingValues(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbSetStartingValues. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbSetStartingValues(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetInputErrors) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetInputErrors(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbSetInputErrors. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbSetInputErrors(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetStartingValues) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetStartingValues(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbGetStartingValues. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbGetStartingValues(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetInputErrors) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetInputErrors(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbGetInputErrors. Expected glb_params.");
        XSRETURN(1);
    }
    _result = (int )glbGetInputErrors(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiTheta) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiTheta(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiTheta. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiTheta. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiTheta(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiTheta23) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiTheta23(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiTheta23. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiTheta23. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiTheta23(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiDelta) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiDelta(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiDelta. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiDelta. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiDelta(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiDms) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiDms(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiDms. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiDms. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiDms(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiDm) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiDm(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiDm. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiDm. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiDm(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiThetaDelta) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiThetaDelta(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiThetaDelta. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiThetaDelta. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiThetaDelta(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiAll) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiAll(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiAll. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiAll. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiAll(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetProjection) {

    int  _result;
    glb_projection  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetProjection(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbSetProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    _result = (int )glbSetProjection(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetProjection) {

    int  _result;
    glb_projection  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetProjection(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_projection")) {
        croak("Type error in argument 1 of glbGetProjection. Expected glb_projection.");
        XSRETURN(1);
    }
    _result = (int )glbGetProjection(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbChiNP) {

    int  _arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    glb_params  _arg0,_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbChiNP(in,out,exp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_params")) {
        croak("Type error in argument 1 of glbChiNP. Expected glb_params.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_params")) {
        croak("Type error in argument 2 of glbChiNP. Expected glb_params.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbChiNP(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetExperiment) {

    glb_exp  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetExperiment(in);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_exp")) {
        croak("Type error in argument 1 of glbSetExperiment. Expected glb_exp.");
        XSRETURN(1);
    }
    glbSetExperiment(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_glbDefaultExp) {

    int  _result;
    glb_exp  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbDefaultExp(ins);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_exp")) {
        croak("Type error in argument 1 of glbDefaultExp. Expected glb_exp.");
        XSRETURN(1);
    }
    _result = (int )glbDefaultExp(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbInitExp) {

    glb_exp  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbInitExp(ins);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_exp")) {
        croak("Type error in argument 1 of glbInitExp. Expected glb_exp.");
        XSRETURN(1);
    }
    glbInitExp(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_glbAllocExp) {

    glb_exp  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbAllocExp();");
    _result = (glb_exp )glbAllocExp();
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_exp", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbFreeExp) {

    glb_exp  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbFreeExp(ins);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_exp")) {
        croak("Type error in argument 1 of glbFreeExp. Expected glb_exp.");
        XSRETURN(1);
    }
    glbFreeExp(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_glbSetNewRates) {

    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbSetNewRates();");
    glbSetNewRates();
    XSRETURN(argvi);
}

XS(_wrap_glbSetRates) {

    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbSetRates();");
    glbSetRates();
    XSRETURN(argvi);
}

XS(_wrap_glbSetErrorDim) {

    int  _result,_arg0,_arg1,_arg2,_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbSetErrorDim(experiment,rule,on_off,value);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _result = (int )glbSetErrorDim(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetErrorDim) {

    int  _result,_arg0,_arg1,_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbGetErrorDim(experiment,rule,on_off);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (int )glbGetErrorDim(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSwitchSystematics) {

    int  _result,_arg0,_arg1,_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSwitchSystematics(experiment,rule,on_off);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (int )glbSwitchSystematics(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetTargetMass) {

    int  _result,_arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbSetTargetMass(experiment,mass);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (int )glbSetTargetMass(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetTargetMass) {

    int  _arg0;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetTargetMass(experiment);");
    _arg0 = (int )SvIV(ST(0));
    _result = (double )glbGetTargetMass(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetSignalErrors) {

    int  _result,_arg0,_arg1;
    double  _arg2,_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbSetSignalErrors(experiment,rule,norm,tilt);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _result = (int )glbSetSignalErrors(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetSignalErrors) {

    int  _result,_arg0,_arg1;
    double  *_arg2,*_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbGetSignalErrors(experiment,rule,norm,tilt);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtr")) {
        croak("Type error in argument 3 of glbGetSignalErrors. Expected doublePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtr")) {
        croak("Type error in argument 4 of glbGetSignalErrors. Expected doublePtr.");
        XSRETURN(1);
    }
    _result = (int )glbGetSignalErrors(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetBGErrors) {

    int  _result,_arg0,_arg1;
    double  _arg2,_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbSetBGErrors(experiment,rule,norm,tilt);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _result = (int )glbSetBGErrors(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetBGErrors) {

    int  _result,_arg0,_arg1;
    double  *_arg2,*_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbGetBGErrors(experiment,rule,norm,tilt);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtr")) {
        croak("Type error in argument 3 of glbGetBGErrors. Expected doublePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtr")) {
        croak("Type error in argument 4 of glbGetBGErrors. Expected doublePtr.");
        XSRETURN(1);
    }
    _result = (int )glbGetBGErrors(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetBGCenters) {

    int  _result,_arg0,_arg1;
    double  _arg2,_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbSetBGCenters(experiment,rule,norm,tilt);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _result = (int )glbSetBGCenters(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetBGCenters) {

    int  _result,_arg0,_arg1;
    double  *_arg2,*_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbGetBGCenters(experiment,rule,norm,tilt);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtr")) {
        croak("Type error in argument 3 of glbGetBGCenters. Expected doublePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtr")) {
        croak("Type error in argument 4 of glbGetBGCenters. Expected doublePtr.");
        XSRETURN(1);
    }
    _result = (int )glbGetBGCenters(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetNumberOfFluxes) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetNumberOfFluxes(exp);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbGetNumberOfFluxes(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbFlux) {

    int  _arg0,_arg1,_arg4,_arg5;
    double  _result,_arg2,_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 6) || (items > 6)) 
        croak("Usage: glbFlux(experiment,flux_ident,energy,distance,flavour,anti);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _arg3 = (double ) SvNV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _result = (double )glbFlux(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetSourcePower) {

    int  _result,_arg0,_arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetSourcePower(experiment,flux_ident,power);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (int )glbSetSourcePower(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetSourcePower) {

    int  _arg0,_arg1;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbGetSourcePower(experiment,flux_ident);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (double )glbGetSourcePower(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetRunningTime) {

    int  _result,_arg0,_arg1;
    double  _arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetRunningTime(experiment,flux_ident,time);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (double ) SvNV(ST(2));
    _result = (int )glbSetRunningTime(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetRunningTime) {

    int  _arg0,_arg1;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbGetRunningTime(experiment,flux_ident);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (double )glbGetRunningTime(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbInitExperiment) {

    int  _result,*_arg2;
    glb_exp  *_arg1;
    int argvi = 0;
    dXSARGS ;
    char  *_arg0;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbInitExperiment(inf,in,counter);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"glb_expPtr")) {
        croak("Type error in argument 2 of glbInitExperiment. Expected glb_expPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"intPtr")) {
        croak("Type error in argument 3 of glbInitExperiment. Expected intPtr.");
        XSRETURN(1);
    }
    _result = (int )glbInitExperiment(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbClearExperimentList) {

    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbClearExperimentList();");
    glbClearExperimentList();
    XSRETURN(argvi);
}

XS(_wrap_glbInit) {

    int argvi = 0;
    dXSARGS ;
    char  *_arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbInit(name);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    glbInit(_arg0);
    XSRETURN(argvi);
}

XS(_wrap_glbResetRateStack) {

    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbResetRateStack();");
    glbResetRateStack();
    XSRETURN(argvi);
}

XS(_wrap_glbGetNumberOfChannels) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetNumberOfChannels(exp);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbGetNumberOfChannels(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetChannelRates) {

    int  _result,_arg2,_arg3,_arg4;
    double  **_arg0;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg1;
    cv = cv;
    if ((items < 5) || (items > 5)) 
        croak("Usage: glbGetChannelRates(data,length,exp,channel,smearing);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"doublePtrPtr")) {
        croak("Type error in argument 1 of glbGetChannelRates. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"size_tPtr")) {
        croak("Type error in argument 2 of glbGetChannelRates. Expected size_tPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _result = (int )glbGetChannelRates(_arg0,_arg1,_arg2,_arg3,_arg4);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetUserData) {

    int  _result,_arg2,_arg3,_arg4,_arg5;
    double  **_arg0;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg1;
    cv = cv;
    if ((items < 6) || (items > 6)) 
        croak("Usage: glbGetUserData(data,length,exp,channel,smearing,bgeff);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"doublePtrPtr")) {
        croak("Type error in argument 1 of glbGetUserData. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"size_tPtr")) {
        croak("Type error in argument 2 of glbGetUserData. Expected size_tPtr.");
        XSRETURN(1);
    }
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _result = (int )glbGetUserData(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbTotalRuleRate) {

    int  _arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 7) || (items > 7)) 
        croak("Usage: glbTotalRuleRate(exp,rule,pos,effi,bgi,coeffi,signal);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _result = (double )glbTotalRuleRate(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetNumberOfRules) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetNumberOfRules(exp);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbGetNumberOfRules(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetLengthOfRule) {

    int  _result,_arg0,_arg1,_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbGetLengthOfRule(exp,rule,signal);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (int )glbGetLengthOfRule(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetNormalizationInRule) {

    int  _arg0,_arg1,_arg2;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbGetNormalizationInRule(exp,rule,signal);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _result = (double )glbGetNormalizationInRule(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetChannelInRule) {

    int  _result,_arg0,_arg1,_arg2,_arg3;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbGetChannelInRule(exp,rule,pos,signal);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _result = (int )glbGetChannelInRule(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetCoefficientInRule) {

    int  _arg0,_arg1,_arg2,_arg3;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbGetCoefficientInRule(exp,rule,pos,signal);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _result = (double )glbGetCoefficientInRule(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbShowRuleRates) {

    FILE  *_arg0;
    int  _result,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 8) || (items > 8)) 
        croak("Usage: glbShowRuleRates(stream,exp,rule,pos,effi,bgi,coeffi,signal);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of glbShowRuleRates. Expected FILEPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _arg6 = (int )SvIV(ST(6));
    _arg7 = (int )SvIV(ST(7));
    _result = (int )glbShowRuleRates(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5,_arg6,_arg7);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbShowChannelRates) {

    FILE  *_arg0;
    int  _result,_arg1,_arg2,_arg3,_arg4,_arg5;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 6) || (items > 6)) 
        croak("Usage: glbShowChannelRates(stream,exp,channel,smearing,effi,bgi);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"FILEPtr")) {
        croak("Type error in argument 1 of glbShowChannelRates. Expected FILEPtr.");
        XSRETURN(1);
    }
    _arg1 = (int )SvIV(ST(1));
    _arg2 = (int )SvIV(ST(2));
    _arg3 = (int )SvIV(ST(3));
    _arg4 = (int )SvIV(ST(4));
    _arg5 = (int )SvIV(ST(5));
    _result = (int )glbShowChannelRates(_arg0,_arg1,_arg2,_arg3,_arg4,_arg5);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetChannelPrintFunction) {

    void  *_result,*_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetChannelPrintFunction(fp);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,(char *) 0 )) {
        croak("Type error in argument 1 of glbSetChannelPrintFunction. Expected voidPtr.");
        XSRETURN(1);
    }
    _result = (void *)glbSetChannelPrintFunction(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"voidPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetPrintDelimiters) {

    int argvi = 0;
    dXSARGS ;
    char  *_arg0,*_arg1,*_arg2;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbSetPrintDelimiters(left,middle,right);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    glbSetPrintDelimiters(_arg0,_arg1,_arg2);
    XSRETURN(argvi);
}

XS(_wrap_glbGetProfileTypeInExperiment) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetProfileTypeInExperiment(exp);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbGetProfileTypeInExperiment(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbLoadProfileData) {

    int  _result;
    double  **_arg2,**_arg3;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg1;
    char  *_arg0;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbLoadProfileData(filename,layers,length,density);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"size_tPtr")) {
        croak("Type error in argument 2 of glbLoadProfileData. Expected size_tPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtrPtr")) {
        croak("Type error in argument 3 of glbLoadProfileData. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtrPtr")) {
        croak("Type error in argument 4 of glbLoadProfileData. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    _result = (int )glbLoadProfileData(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbStaceyProfile) {

    int  _result;
    double  _arg0,**_arg2,**_arg3;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg1;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbStaceyProfile(baseline,layers,length,density);");
    _arg0 = (double ) SvNV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"size_tPtr")) {
        croak("Type error in argument 2 of glbStaceyProfile. Expected size_tPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtrPtr")) {
        croak("Type error in argument 3 of glbStaceyProfile. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtrPtr")) {
        croak("Type error in argument 4 of glbStaceyProfile. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    _result = (int )glbStaceyProfile(_arg0,*_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbAverageDensityProfile) {

    int  _result;
    double  _arg0,**_arg1,**_arg2;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbAverageDensityProfile(baseline,length,density);");
    _arg0 = (double ) SvNV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"doublePtrPtr")) {
        croak("Type error in argument 2 of glbAverageDensityProfile. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtrPtr")) {
        croak("Type error in argument 3 of glbAverageDensityProfile. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    _result = (int )glbAverageDensityProfile(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetProfileData) {

    int  _result;
    double  **_arg1,**_arg2;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg0;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbGetProfileData(layers,length,density);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"size_tPtr")) {
        croak("Type error in argument 1 of glbGetProfileData. Expected size_tPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"doublePtrPtr")) {
        croak("Type error in argument 2 of glbGetProfileData. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtrPtr")) {
        croak("Type error in argument 3 of glbGetProfileData. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    _result = (int )glbGetProfileData(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetProfileDataInExperiment) {

    int  _result,_arg0;
    double  **_arg2,**_arg3;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg1;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbGetProfileDataInExperiment(exp,layers,length,density);");
    _arg0 = (int )SvIV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"size_tPtr")) {
        croak("Type error in argument 2 of glbGetProfileDataInExperiment. Expected size_tPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtrPtr")) {
        croak("Type error in argument 3 of glbGetProfileDataInExperiment. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtrPtr")) {
        croak("Type error in argument 4 of glbGetProfileDataInExperiment. Expected doublePtrPtr.");
        XSRETURN(1);
    }
    _result = (int )glbGetProfileDataInExperiment(_arg0,_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetProfileDataInExperiment) {

    int  _result,_arg0;
    double  *_arg2,*_arg3;
    int argvi = 0;
    dXSARGS ;
    size_t  *_arg1;
    cv = cv;
    if ((items < 4) || (items > 4)) 
        croak("Usage: glbSetProfileDataInExperiment(exp,layers,length,density);");
    _arg0 = (int )SvIV(ST(0));
    if (SWIG_GetPtr(ST(1),(void **) &_arg1,"size_tPtr")) {
        croak("Type error in argument 2 of glbSetProfileDataInExperiment. Expected size_tPtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(2),(void **) &_arg2,"doublePtr")) {
        croak("Type error in argument 3 of glbSetProfileDataInExperiment. Expected doublePtr.");
        XSRETURN(1);
    }
    if (SWIG_GetPtr(ST(3),(void **) &_arg3,"doublePtr")) {
        croak("Type error in argument 4 of glbSetProfileDataInExperiment. Expected doublePtr.");
        XSRETURN(1);
    }
    _result = (int )glbSetProfileDataInExperiment(_arg0,*_arg1,_arg2,_arg3);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetBaselineInExperiment) {

    int  _result,_arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbSetBaselineInExperiment(exp,baseline);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (int )glbSetBaselineInExperiment(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetBaselineInExperiment) {

    int  _arg0;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetBaselineInExperiment(exp);");
    _arg0 = (int )SvIV(ST(0));
    _result = (double )glbGetBaselineInExperiment(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbDefineAEDLVariable) {

    double  _arg1;
    int argvi = 0;
    dXSARGS ;
    char  *_arg0;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbDefineAEDLVariable(name,value);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _arg1 = (double ) SvNV(ST(1));
    glbDefineAEDLVariable(_arg0,_arg1);
    XSRETURN(argvi);
}

XS(_wrap_glbClearAEDLVariables) {

    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbClearAEDLVariables();");
    glbClearAEDLVariables();
    XSRETURN(argvi);
}

XS(_wrap_glbTestReleaseVersion) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    char  *_arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbTestReleaseVersion(version);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (int )glbTestReleaseVersion(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbTestLibraryVersion) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    char  *_arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbTestLibraryVersion(version);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (int )glbTestLibraryVersion(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbVersionOfExperiment) {

    int  _arg0;
    int argvi = 0;
    dXSARGS ;
    char  *_result;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbVersionOfExperiment(experiment);");
    _arg0 = (int )SvIV(ST(0));
    _result = (char *)glbVersionOfExperiment(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetFilterState) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetFilterState(on_off);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbSetFilterState(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetFilterState) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbGetFilterState();");
    _result = (int )glbGetFilterState();
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetFilterStateInExperiment) {

    int  _result,_arg0,_arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbSetFilterStateInExperiment(experiment,on_off);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (int )SvIV(ST(1));
    _result = (int )glbSetFilterStateInExperiment(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetFilterStateInExperiment) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetFilterStateInExperiment(experiment);");
    _arg0 = (int )SvIV(ST(0));
    _result = (int )glbGetFilterStateInExperiment(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetFilter) {

    int  _result;
    double  _arg0;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbSetFilter(filter);");
    _arg0 = (double ) SvNV(ST(0));
    _result = (int )glbSetFilter(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetFilter) {

    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 0) || (items > 0)) 
        croak("Usage: glbGetFilter();");
    _result = (double )glbGetFilter();
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSetFilterInExperiment) {

    int  _result,_arg0;
    double  _arg1;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbSetFilterInExperiment(experiment,filter);");
    _arg0 = (int )SvIV(ST(0));
    _arg1 = (double ) SvNV(ST(1));
    _result = (int )glbSetFilterInExperiment(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbGetFilterInExperiment) {

    int  _arg0;
    double  _result;
    int argvi = 0;
    dXSARGS ;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbGetFilterInExperiment(experiment);");
    _arg0 = (int )SvIV(ST(0));
    _result = (double )glbGetFilterInExperiment(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setnv(ST(argvi++), (double) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbNameToValue) {

    int  _result,_arg0;
    int argvi = 0;
    dXSARGS ;
    char  *_arg1,*_arg2;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbNameToValue(exp,context,name);");
    _arg0 = (int )SvIV(ST(0));
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    if (! SvOK((SV*) ST(2))) { _arg2 = 0; }
    else { _arg2 = (char *) SvPV(ST(2),PL_na); }
    _result = (int )glbNameToValue(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbValueToName) {

    int  _arg0,_arg2;
    int argvi = 0;
    dXSARGS ;
    char  *_result,*_arg1;
    cv = cv;
    if ((items < 3) || (items > 3)) 
        croak("Usage: glbValueToName(exp,context,value);");
    _arg0 = (int )SvIV(ST(0));
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _arg2 = (int )SvIV(ST(2));
    _result = (char *)glbValueToName(_arg0,_arg1,_arg2);
    ST(argvi) = sv_newmortal();
    sv_setpv((SV*)ST(argvi++),(char *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbProbeModule) {

    int  _result,_arg1;
    int argvi = 0;
    dXSARGS ;
    char  *_arg0;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbProbeModule(module_name,verbosity);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _arg1 = (int )SvIV(ST(1));
    _result = (int )glbProbeModule(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbOpenModule) {

    int argvi = 0;
    dXSARGS ;
    glb_dlhandle  _result;
    char  *_arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbOpenModule(module_name);");
    if (! SvOK((SV*) ST(0))) { _arg0 = 0; }
    else { _arg0 = (char *) SvPV(ST(0),PL_na); }
    _result = (glb_dlhandle )glbOpenModule(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"glb_dlhandle", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbCloseModule) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_dlhandle  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbCloseModule(stale);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_dlhandle")) {
        croak("Type error in argument 1 of glbCloseModule. Expected glb_dlhandle.");
        XSRETURN(1);
    }
    _result = (int )glbCloseModule(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbSymModule) {

    void  *_result;
    int argvi = 0;
    dXSARGS ;
    glb_dlhandle  _arg0;
    char  *_arg1;
    cv = cv;
    if ((items < 2) || (items > 2)) 
        croak("Usage: glbSymModule(module,symbol_name);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_dlhandle")) {
        croak("Type error in argument 1 of glbSymModule. Expected glb_dlhandle.");
        XSRETURN(1);
    }
    if (! SvOK((SV*) ST(1))) { _arg1 = 0; }
    else { _arg1 = (char *) SvPV(ST(1),PL_na); }
    _result = (void *)glbSymModule(_arg0,_arg1);
    ST(argvi) = sv_newmortal();
    sv_setref_pv(ST(argvi++),"voidPtr", (void *) _result);
    XSRETURN(argvi);
}

XS(_wrap_glbUsePrior) {

    int  _result;
    int argvi = 0;
    dXSARGS ;
    glb_dlhandle  _arg0;
    cv = cv;
    if ((items < 1) || (items > 1)) 
        croak("Usage: glbUsePrior(module);");
    if (SWIG_GetPtr(ST(0),(void **) &_arg0,"glb_dlhandle")) {
        croak("Type error in argument 1 of glbUsePrior. Expected glb_dlhandle.");
        XSRETURN(1);
    }
    _result = (int )glbUsePrior(_arg0);
    ST(argvi) = sv_newmortal();
    sv_setiv(ST(argvi++),(IV) _result);
    XSRETURN(argvi);
}

/*
 * This table is used by the pointer type-checker
 */
static struct { char *n1; char *n2; void *(*pcnv)(void *); } _swig_mapping[] = {
    { "unsigned int","int",0},
    { "signed int","int",0},
    { "glb_dlhandle","struct lt_dlhandle_structPtr",0},
    { "unsigned long","long",0},
    { "signed long","long",0},
    { "glb_projection","struct glb_projection_typePtr",0},
    { "glb_exp","struct glb_experimentPtr",0},
    { "glb_params","struct glb_params_typePtr",0},
    { "long","unsigned long",0},
    { "long","signed long",0},
    { "struct glb_experimentPtr","glb_exp",0},
    { "struct glb_params_typePtr","glb_params",0},
    { "struct glb_projection_typePtr","glb_projection",0},
    { "int","unsigned int",0},
    { "int","signed int",0},
    { "unsigned short","short",0},
    { "signed short","short",0},
    { "struct lt_dlhandle_structPtr","glb_dlhandle",0},
    { "short","unsigned short",0},
    { "short","signed short",0},
{0,0,0}};

/*
typedef struct {
    const char *name; 
    void *(*convert)(void *);
} SwigType;
static SwigType unsigned int[] = {{ "int", 0},{0,0}};
static SwigType signed int[] = {{ "int", 0},{0,0}};
static SwigType glb_dlhandle[] = {{ "struct lt_dlhandle_structPtr", 0},{0,0}};
static SwigType unsigned long[] = {{ "long", 0},{0,0}};
static SwigType signed long[] = {{ "long", 0},{0,0}};
static SwigType glb_projection[] = {{ "struct glb_projection_typePtr", 0},{0,0}};
static SwigType glb_exp[] = {{ "struct glb_experimentPtr", 0},{0,0}};
static SwigType glb_params[] = {{ "struct glb_params_typePtr", 0},{0,0}};
static SwigType long[] = {{ "unsigned long", 0},{ "signed long", 0},{0,0}};
static SwigType struct glb_experimentPtr[] = {{ "glb_exp", 0},{0,0}};
static SwigType struct glb_params_typePtr[] = {{ "glb_params", 0},{0,0}};
static SwigType struct glb_projection_typePtr[] = {{ "glb_projection", 0},{0,0}};
static SwigType int[] = {{ "unsigned int", 0},{ "signed int", 0},{0,0}};
static SwigType unsigned short[] = {{ "short", 0},{0,0}};
static SwigType signed short[] = {{ "short", 0},{0,0}};
static SwigType struct lt_dlhandle_structPtr[] = {{ "glb_dlhandle", 0},{0,0}};
static SwigType short[] = {{ "unsigned short", 0},{ "signed short", 0},{0,0}};
*/

XS(_wrap_perl5_globes_var_init) {
    dXSARGS;
    SV *sv;
    cv = cv; items = items;
    swig_setiv("globes::GLS_GLOBES_H", (long) 1);
    swig_setiv("globes::GLB_EFF", (long) 1);
    swig_setiv("globes::GLB_BG", (long) 2);
    swig_setiv("globes::GLB_SIG", (long) 3);
    swig_setiv("globes::GLB_PRE", (long) 1);
    swig_setiv("globes::GLB_POST", (long) 2);
    swig_setiv("globes::GLB_OSCP", (long) 6);
    swig_setiv("globes::GLB_ALL", (long) -1);
    swig_setiv("globes::GLB_W_EFF", (long) 1);
    swig_setiv("globes::GLB_WO_EFF", (long) 2);
    swig_setiv("globes::GLB_W_BG", (long) 3);
    swig_setiv("globes::GLB_WO_BG", (long) 4);
    swig_setiv("globes::GLB_W_COEFF", (long) 5);
    swig_setiv("globes::GLB_WO_COEFF", (long) 6);
    swig_setiv("globes::GLB_FIXED", (long) 0);
    swig_setiv("globes::GLB_FREE", (long) 1);
    swig_setiv("globes::GLB_THETA_12", (long) 0);
    swig_setiv("globes::GLB_THETA_13", (long) 1);
    swig_setiv("globes::GLB_THETA_23", (long) 2);
    swig_setiv("globes::GLB_DELTA_CP", (long) 3);
    swig_setiv("globes::GLB_DM_SOL", (long) 4);
    swig_setiv("globes::GLB_DM_ATM", (long) 5);
    swig_setiv("globes::GLB_ON", (long) 1);
    swig_setiv("globes::GLB_OFF", (long) 0);
    swig_setnv("globes::GLB_EARTH_RADIUS", (double) (6371.0));
    sv = perl_get_sv("globes::glb_path_vector",TRUE | 0x2);
    sv_setref_pv(sv,"charPtrPtr",(void *) 1);
    swig_create_magic(sv,"globes::glb_path_vector", MAGIC_CAST MAGIC_CLASS _wrap_set_glb_path_vector, MAGIC_CAST MAGIC_CLASS _wrap_val_glb_path_vector);
    sv = perl_get_sv("globes::glb_path_vector_length",TRUE | 0x2);
    sv_setref_pv(sv,"size_tPtr",(void *) &glb_path_vector_length);
    swig_create_magic(sv,"globes::glb_path_vector_length", MAGIC_CAST MAGIC_CLASS _wrap_set_glb_path_vector_length, MAGIC_CAST MAGIC_CLASS _wrap_val_glb_path_vector_length);
    sv = perl_get_sv("globes::glb_num_of_exps",TRUE | 0x2);
    sv_setiv(sv,(IV)glb_num_of_exps);
    swig_create_magic(sv,"globes::glb_num_of_exps", MAGIC_CAST MAGIC_CLASS _wrap_set_glb_num_of_exps, MAGIC_CAST MAGIC_CLASS _wrap_val_glb_num_of_exps);
    sv = perl_get_sv("globes::glb_single_experiment_number",TRUE | 0x2);
    sv_setiv(sv,(IV)glb_single_experiment_number);
    swig_create_magic(sv,"globes::glb_single_experiment_number", MAGIC_CAST MAGIC_CLASS _wrap_set_glb_single_experiment_number, MAGIC_CAST MAGIC_CLASS _wrap_val_glb_single_experiment_number);
    sv = perl_get_sv("globes::glb_experiment_list",TRUE | 0x2);
    sv_setref_pv(sv,"glb_expPtr",(void *) 1);
    swig_create_magic(sv,"globes::glb_experiment_list",MAGIC_CAST MAGIC_CLASS swig_magic_readonly, MAGIC_CAST MAGIC_CLASS _wrap_val_glb_experiment_list);
    sv = perl_get_sv("globes::glb_rule_number",TRUE | 0x2);
    sv_setiv(sv,(IV)glb_rule_number);
    swig_create_magic(sv,"globes::glb_rule_number", MAGIC_CAST MAGIC_CLASS _wrap_set_glb_rule_number, MAGIC_CAST MAGIC_CLASS _wrap_val_glb_rule_number);
    XSRETURN(1);
}
#ifdef __cplusplus
extern "C"
#endif
XS(SWIG_init) {
	 dXSARGS;
	 char *file = __FILE__;
	 cv = cv; items = items;
	 newXS("globes::var_globes_init", _wrap_perl5_globes_var_init, file);
	 newXS("globes::glbSetVerbosityLevel", _wrap_glbSetVerbosityLevel, file);
	 newXS("globes::glbPrintDelimiter", _wrap_glbPrintDelimiter, file);
	 newXS("globes::glbSetIteration", _wrap_glbSetIteration, file);
	 newXS("globes::glbGetIteration", _wrap_glbGetIteration, file);
	 newXS("globes::glbCopyParams", _wrap_glbCopyParams, file);
	 newXS("globes::glbDefineParams", _wrap_glbDefineParams, file);
	 newXS("globes::glbAllocParams", _wrap_glbAllocParams, file);
	 newXS("globes::glbFreeParams", _wrap_glbFreeParams, file);
	 newXS("globes::glbSetDensityParams", _wrap_glbSetDensityParams, file);
	 newXS("globes::glbGetDensityParams", _wrap_glbGetDensityParams, file);
	 newXS("globes::glbSetOscParams", _wrap_glbSetOscParams, file);
	 newXS("globes::glbGetOscParams", _wrap_glbGetOscParams, file);
	 newXS("globes::glbPrintParams", _wrap_glbPrintParams, file);
	 newXS("globes::glbSetProjectionFlag", _wrap_glbSetProjectionFlag, file);
	 newXS("globes::glbGetProjectionFlag", _wrap_glbGetProjectionFlag, file);
	 newXS("globes::glbSetDensityProjectionFlag", _wrap_glbSetDensityProjectionFlag, file);
	 newXS("globes::glbGetDensityProjectionFlag", _wrap_glbGetDensityProjectionFlag, file);
	 newXS("globes::glbCopyProjection", _wrap_glbCopyProjection, file);
	 newXS("globes::glbDefineProjection", _wrap_glbDefineProjection, file);
	 newXS("globes::glbAllocProjection", _wrap_glbAllocProjection, file);
	 newXS("globes::glbFreeProjection", _wrap_glbFreeProjection, file);
	 newXS("globes::glbPrintProjection", _wrap_glbPrintProjection, file);
	 newXS("globes::glbSetOscillationParameters", _wrap_glbSetOscillationParameters, file);
	 newXS("globes::glbGetOscillationParameters", _wrap_glbGetOscillationParameters, file);
	 newXS("globes::glbVacuumProbability", _wrap_glbVacuumProbability, file);
	 newXS("globes::glbProfileProbability", _wrap_glbProfileProbability, file);
	 newXS("globes::glbXSection", _wrap_glbXSection, file);
	 newXS("globes::glbChiSys", _wrap_glbChiSys, file);
	 newXS("globes::glbSetStartingValues", _wrap_glbSetStartingValues, file);
	 newXS("globes::glbSetInputErrors", _wrap_glbSetInputErrors, file);
	 newXS("globes::glbGetStartingValues", _wrap_glbGetStartingValues, file);
	 newXS("globes::glbGetInputErrors", _wrap_glbGetInputErrors, file);
	 newXS("globes::glbChiTheta", _wrap_glbChiTheta, file);
	 newXS("globes::glbChiTheta23", _wrap_glbChiTheta23, file);
	 newXS("globes::glbChiDelta", _wrap_glbChiDelta, file);
	 newXS("globes::glbChiDms", _wrap_glbChiDms, file);
	 newXS("globes::glbChiDm", _wrap_glbChiDm, file);
	 newXS("globes::glbChiThetaDelta", _wrap_glbChiThetaDelta, file);
	 newXS("globes::glbChiAll", _wrap_glbChiAll, file);
	 newXS("globes::glbSetProjection", _wrap_glbSetProjection, file);
	 newXS("globes::glbGetProjection", _wrap_glbGetProjection, file);
	 newXS("globes::glbChiNP", _wrap_glbChiNP, file);
	 newXS("globes::glbSetExperiment", _wrap_glbSetExperiment, file);
	 newXS("globes::glbDefaultExp", _wrap_glbDefaultExp, file);
	 newXS("globes::glbInitExp", _wrap_glbInitExp, file);
	 newXS("globes::glbAllocExp", _wrap_glbAllocExp, file);
	 newXS("globes::glbFreeExp", _wrap_glbFreeExp, file);
	 newXS("globes::glbSetNewRates", _wrap_glbSetNewRates, file);
	 newXS("globes::glbSetRates", _wrap_glbSetRates, file);
	 newXS("globes::glbSetErrorDim", _wrap_glbSetErrorDim, file);
	 newXS("globes::glbGetErrorDim", _wrap_glbGetErrorDim, file);
	 newXS("globes::glbSwitchSystematics", _wrap_glbSwitchSystematics, file);
	 newXS("globes::glbSetTargetMass", _wrap_glbSetTargetMass, file);
	 newXS("globes::glbGetTargetMass", _wrap_glbGetTargetMass, file);
	 newXS("globes::glbSetSignalErrors", _wrap_glbSetSignalErrors, file);
	 newXS("globes::glbGetSignalErrors", _wrap_glbGetSignalErrors, file);
	 newXS("globes::glbSetBGErrors", _wrap_glbSetBGErrors, file);
	 newXS("globes::glbGetBGErrors", _wrap_glbGetBGErrors, file);
	 newXS("globes::glbSetBGCenters", _wrap_glbSetBGCenters, file);
	 newXS("globes::glbGetBGCenters", _wrap_glbGetBGCenters, file);
	 newXS("globes::glbGetNumberOfFluxes", _wrap_glbGetNumberOfFluxes, file);
	 newXS("globes::glbFlux", _wrap_glbFlux, file);
	 newXS("globes::glbSetSourcePower", _wrap_glbSetSourcePower, file);
	 newXS("globes::glbGetSourcePower", _wrap_glbGetSourcePower, file);
	 newXS("globes::glbSetRunningTime", _wrap_glbSetRunningTime, file);
	 newXS("globes::glbGetRunningTime", _wrap_glbGetRunningTime, file);
	 newXS("globes::glbInitExperiment", _wrap_glbInitExperiment, file);
	 newXS("globes::glbClearExperimentList", _wrap_glbClearExperimentList, file);
	 newXS("globes::glbInit", _wrap_glbInit, file);
	 newXS("globes::glbResetRateStack", _wrap_glbResetRateStack, file);
	 newXS("globes::glbGetNumberOfChannels", _wrap_glbGetNumberOfChannels, file);
	 newXS("globes::glbGetChannelRates", _wrap_glbGetChannelRates, file);
	 newXS("globes::glbGetUserData", _wrap_glbGetUserData, file);
	 newXS("globes::glbTotalRuleRate", _wrap_glbTotalRuleRate, file);
	 newXS("globes::glbGetNumberOfRules", _wrap_glbGetNumberOfRules, file);
	 newXS("globes::glbGetLengthOfRule", _wrap_glbGetLengthOfRule, file);
	 newXS("globes::glbGetNormalizationInRule", _wrap_glbGetNormalizationInRule, file);
	 newXS("globes::glbGetChannelInRule", _wrap_glbGetChannelInRule, file);
	 newXS("globes::glbGetCoefficientInRule", _wrap_glbGetCoefficientInRule, file);
	 newXS("globes::glbShowRuleRates", _wrap_glbShowRuleRates, file);
	 newXS("globes::glbShowChannelRates", _wrap_glbShowChannelRates, file);
	 newXS("globes::glbSetChannelPrintFunction", _wrap_glbSetChannelPrintFunction, file);
	 newXS("globes::glbSetPrintDelimiters", _wrap_glbSetPrintDelimiters, file);
	 newXS("globes::glbGetProfileTypeInExperiment", _wrap_glbGetProfileTypeInExperiment, file);
	 newXS("globes::glbLoadProfileData", _wrap_glbLoadProfileData, file);
	 newXS("globes::glbStaceyProfile", _wrap_glbStaceyProfile, file);
	 newXS("globes::glbAverageDensityProfile", _wrap_glbAverageDensityProfile, file);
	 newXS("globes::glbGetProfileData", _wrap_glbGetProfileData, file);
	 newXS("globes::glbGetProfileDataInExperiment", _wrap_glbGetProfileDataInExperiment, file);
	 newXS("globes::glbSetProfileDataInExperiment", _wrap_glbSetProfileDataInExperiment, file);
	 newXS("globes::glbSetBaselineInExperiment", _wrap_glbSetBaselineInExperiment, file);
	 newXS("globes::glbGetBaselineInExperiment", _wrap_glbGetBaselineInExperiment, file);
	 newXS("globes::glbDefineAEDLVariable", _wrap_glbDefineAEDLVariable, file);
	 newXS("globes::glbClearAEDLVariables", _wrap_glbClearAEDLVariables, file);
	 newXS("globes::glbTestReleaseVersion", _wrap_glbTestReleaseVersion, file);
	 newXS("globes::glbTestLibraryVersion", _wrap_glbTestLibraryVersion, file);
	 newXS("globes::glbVersionOfExperiment", _wrap_glbVersionOfExperiment, file);
	 newXS("globes::glbSetFilterState", _wrap_glbSetFilterState, file);
	 newXS("globes::glbGetFilterState", _wrap_glbGetFilterState, file);
	 newXS("globes::glbSetFilterStateInExperiment", _wrap_glbSetFilterStateInExperiment, file);
	 newXS("globes::glbGetFilterStateInExperiment", _wrap_glbGetFilterStateInExperiment, file);
	 newXS("globes::glbSetFilter", _wrap_glbSetFilter, file);
	 newXS("globes::glbGetFilter", _wrap_glbGetFilter, file);
	 newXS("globes::glbSetFilterInExperiment", _wrap_glbSetFilterInExperiment, file);
	 newXS("globes::glbGetFilterInExperiment", _wrap_glbGetFilterInExperiment, file);
	 newXS("globes::glbNameToValue", _wrap_glbNameToValue, file);
	 newXS("globes::glbValueToName", _wrap_glbValueToName, file);
	 newXS("globes::glbProbeModule", _wrap_glbProbeModule, file);
	 newXS("globes::glbOpenModule", _wrap_glbOpenModule, file);
	 newXS("globes::glbCloseModule", _wrap_glbCloseModule, file);
	 newXS("globes::glbSymModule", _wrap_glbSymModule, file);
	 newXS("globes::glbUsePrior", _wrap_glbUsePrior, file);
{
   int i;
   for (i = 0; _swig_mapping[i].n1; i++)
        SWIG_RegisterMapping(_swig_mapping[i].n1,_swig_mapping[i].n2,_swig_mapping[i].pcnv);
}
	 ST(0) = &PL_sv_yes;
	 XSRETURN(1);
}
